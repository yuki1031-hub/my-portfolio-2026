{"ast":null,"code":"import _objectSpread from \"C:/Users/hishi/Documents/\\u30DD\\u30FC\\u30C8\\u30D5\\u30A9\\u30EA\\u30AA2026/portfolio/my-portfolio-2026/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { pipe, warning } from 'motion-utils';\nimport { isCSSVariableToken } from '../../animation/utils/is-css-variable.mjs';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { mixColor } from './color.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber as mixNumber$1 } from './number.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\nfunction mixNumber(a, b) {\n  return p => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n  if (typeof a === \"number\") {\n    return mixNumber;\n  } else if (typeof a === \"string\") {\n    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;\n  } else if (Array.isArray(a)) {\n    return mixArray;\n  } else if (typeof a === \"object\") {\n    return color.test(a) ? mixColor : mixObject;\n  }\n  return mixImmediate;\n}\nfunction mixArray(a, b) {\n  const output = [...a];\n  const numValues = output.length;\n  const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n  return p => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](p);\n    }\n    return output;\n  };\n}\nfunction mixObject(a, b) {\n  const output = _objectSpread(_objectSpread({}, a), b);\n  const blendValue = {};\n  for (const key in output) {\n    if (a[key] !== undefined && b[key] !== undefined) {\n      blendValue[key] = getMixer(a[key])(a[key], b[key]);\n    }\n  }\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n    return output;\n  };\n}\nfunction matchOrder(origin, target) {\n  const orderedOrigin = [];\n  const pointers = {\n    color: 0,\n    var: 0,\n    number: 0\n  };\n  for (let i = 0; i < target.values.length; i++) {\n    var _origin$values$origin;\n    const type = target.types[i];\n    const originIndex = origin.indexes[type][pointers[type]];\n    const originValue = (_origin$values$origin = origin.values[originIndex]) !== null && _origin$values$origin !== void 0 ? _origin$values$origin : 0;\n    orderedOrigin[i] = originValue;\n    pointers[type]++;\n  }\n  return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyseComplexValue(origin);\n  const targetStats = analyseComplexValue(target);\n  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;\n  if (canInterpolate) {\n    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {\n      return mixVisibility(origin, target);\n    }\n    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n  } else {\n    warning(true, \"Complex values '\".concat(origin, \"' and '\").concat(target, \"' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.\"), \"complex-values-different\");\n    return mixImmediate(origin, target);\n  }\n};\nexport { getMixer, mixArray, mixComplex, mixObject };","map":{"version":3,"names":["mixNumber","a","b","p","mixNumber$1","getMixer","isCSSVariableToken","mixImmediate","color","test","mixColor","mixComplex","Array","isArray","mixArray","mixObject","output","numValues","length","blendValue","map","v","i","_objectSpread","key","undefined","matchOrder","origin","target","orderedOrigin","pointers","var","number","values","_origin$values$origin","type","types","originIndex","indexes","originValue","template","complex","createTransformer","originStats","analyseComplexValue","targetStats","canInterpolate","invisibleValues","has","mixVisibility","pipe","warning","concat"],"sources":["C:\\Users\\hishi\\Documents\\ポートフォリオ2026\\portfolio\\my-portfolio-2026\\node_modules\\motion-dom\\src\\utils\\mix\\complex.ts"],"sourcesContent":["import { pipe, warning } from \"motion-utils\"\nimport { AnyResolvedKeyframe } from \"../../animation/types\"\nimport { isCSSVariableToken } from \"../../animation/utils/is-css-variable\"\nimport { color } from \"../../value/types/color\"\nimport {\n    analyseComplexValue,\n    complex,\n    ComplexValueInfo,\n    ComplexValues,\n} from \"../../value/types/complex\"\nimport { HSLA, RGBA } from \"../../value/types/types\"\nimport { mixColor } from \"./color\"\nimport { mixImmediate } from \"./immediate\"\nimport { mixNumber as mixNumberImmediate } from \"./number\"\nimport { invisibleValues, mixVisibility } from \"./visibility\"\n\ntype MixableArray = Array<number | RGBA | HSLA | string>\ninterface MixableObject {\n    [key: string]: AnyResolvedKeyframe | RGBA | HSLA\n}\n\nfunction mixNumber(a: number, b: number) {\n    return (p: number) => mixNumberImmediate(a, b, p)\n}\n\nexport function getMixer<T>(a: T) {\n    if (typeof a === \"number\") {\n        return mixNumber\n    } else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n            ? mixColor\n            : mixComplex\n    } else if (Array.isArray(a)) {\n        return mixArray\n    } else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject\n    }\n\n    return mixImmediate\n}\n\nexport function mixArray(a: MixableArray, b: MixableArray) {\n    const output = [...a]\n    const numValues = output.length\n\n    const blendValue = a.map((v, i) => getMixer(v)(v as any, b[i] as any))\n\n    return (p: number) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p) as any\n        }\n        return output\n    }\n}\n\nexport function mixObject(a: MixableObject, b: MixableObject) {\n    const output = { ...a, ...b }\n    const blendValue: { [key: string]: (v: number) => any } = {}\n\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(\n                a[key] as any,\n                b[key] as any\n            ) as any\n        }\n    }\n\n    return (v: number) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v)\n        }\n        return output\n    }\n}\n\nfunction matchOrder(\n    origin: ComplexValueInfo,\n    target: ComplexValueInfo\n): ComplexValues {\n    const orderedOrigin: ComplexValues = []\n\n    const pointers = { color: 0, var: 0, number: 0 }\n\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i]\n        const originIndex = origin.indexes[type][pointers[type]]\n        const originValue = origin.values[originIndex] ?? 0\n\n        orderedOrigin[i] = originValue\n\n        pointers[type]++\n    }\n\n    return orderedOrigin\n}\n\nexport const mixComplex = (\n    origin: AnyResolvedKeyframe,\n    target: AnyResolvedKeyframe\n) => {\n    const template = complex.createTransformer(target)\n    const originStats = analyseComplexValue(origin)\n    const targetStats = analyseComplexValue(target)\n    const canInterpolate =\n        originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length\n\n    if (canInterpolate) {\n        if (\n            (invisibleValues.has(origin as string) &&\n                !targetStats.values.length) ||\n            (invisibleValues.has(target as string) &&\n                !originStats.values.length)\n        ) {\n            return mixVisibility(origin as string, target as string)\n        }\n\n        return pipe(\n            mixArray(matchOrder(originStats, targetStats), targetStats.values),\n            template\n        )\n    } else {\n        warning(\n            true,\n            `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`,\n            \"complex-values-different\"\n        )\n\n        return mixImmediate(origin, target)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}