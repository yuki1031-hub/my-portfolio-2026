{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\hishi\\\\Documents\\\\\\u30DD\\u30FC\\u30C8\\u30D5\\u30A9\\u30EA\\u30AA2026\\\\portfolio\\\\my-portfolio-2026\\\\src\\\\components\\\\PixelBackground.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PixelBackground = () => {\n  _s();\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    let width, height;\n    let animationFrameId;\n\n    // Settings\n    const pixelSize = 25;\n    const gap = 2;\n    const gridColor = {\n      r: 20,\n      g: 20,\n      b: 30\n    }; // Dark background\n\n    // Swarm settings\n    const agentCount = 12;\n    const agents = [];\n    let hue = 260; // Starting hue (Purple)\n\n    let mouse = {\n      x: -1000,\n      y: -1000\n    };\n\n    // Agent Class representing a \"cell\" of the living entity\n    class Agent {\n      constructor() {\n        this.x = width / 2 + (Math.random() - 0.5) * 200;\n        this.y = height / 2 + (Math.random() - 0.5) * 200;\n        this.vx = (Math.random() - 0.5) * 2;\n        this.vy = (Math.random() - 0.5) * 2;\n        this.radius = 100 + Math.random() * 100; // Influence radius\n        this.noiseOffset = Math.random() * 1000;\n      }\n      update(time) {\n        // 1. Organic Movement (Perlin-ish noise via sin/cos)\n        this.vx += Math.sin(time * 0.002 + this.noiseOffset) * 0.05;\n        this.vy += Math.cos(time * 0.002 + this.noiseOffset) * 0.05;\n\n        // 2. Cohesion (Attract to center of screen to keep the blob somewhat together)\n        const centerX = width / 2;\n        const centerY = height / 2;\n        const dx = centerX - this.x;\n        const dy = centerY - this.y;\n        this.vx += dx * 0.0001;\n        this.vy += dy * 0.0001;\n\n        // 3. Mouse Repulsion (Scattering)\n        const dmx = this.x - mouse.x;\n        const dmy = this.y - mouse.y;\n        const distMouse = Math.sqrt(dmx * dmx + dmy * dmy);\n        const repelRadius = 300;\n        if (distMouse < repelRadius) {\n          const force = (repelRadius - distMouse) / repelRadius;\n          this.vx += dmx / distMouse * force * 1.5;\n          this.vy += dmy / distMouse * force * 1.5;\n        }\n\n        // Friction\n        this.vx *= 0.96;\n        this.vy *= 0.96;\n\n        // Move\n        this.x += this.vx;\n        this.y += this.vy;\n\n        // Boundary check (soft bounce)\n        if (this.x < 0) this.vx += 0.5;\n        if (this.x > width) this.vx -= 0.5;\n        if (this.y < 0) this.vy += 0.5;\n        if (this.y > height) this.vy -= 0.5;\n      }\n    }\n    const init = () => {\n      width = canvas.width = window.innerWidth;\n      height = canvas.height = window.innerHeight;\n      agents.length = 0;\n      for (let i = 0; i < agentCount; i++) {\n        agents.push(new Agent()); // Use the class properly\n      }\n    };\n    const draw = time => {\n      // Clear background\n      ctx.fillStyle = '#020205'; // Very dark background\n      ctx.fillRect(0, 0, width, height);\n\n      // Update Agents\n      agents.forEach(agent => agent.update(time));\n\n      // Cycle Hue\n      hue = (hue + 0.1) % 360;\n\n      // Draw Pixel Grid\n      const cols = Math.ceil(width / (pixelSize + gap));\n      const rows = Math.ceil(height / (pixelSize + gap));\n      for (let i = 0; i < cols; i++) {\n        for (let j = 0; j < rows; j++) {\n          const px = i * (pixelSize + gap);\n          const py = j * (pixelSize + gap);\n\n          // Calculate Field Strength (Metaball-ish)\n          let fieldStrength = 0;\n          for (let agent of agents) {\n            const dx = px - agent.x;\n            const dy = py - agent.y;\n            const dist = Math.sqrt(dx * dx + dy * dy);\n\n            // Inverse square law-ish falloff for smooth blobs\n            if (dist < agent.radius) {\n              fieldStrength += 1 - dist / agent.radius;\n            }\n          }\n\n          // Render Pixel based on strength\n          if (fieldStrength > 0) {\n            // Creating visual thresholding for the \"blob\" look\n            // Power curve to sharpen edges slightly\n            let alpha = Math.min(fieldStrength * 0.8, 0.9);\n\n            // Color blending: Core is white/bright, edges are colored\n            // Using HSL for continuous color cycling\n            ctx.fillStyle = \"hsla(\".concat(hue, \", 80%, \").concat(50 + fieldStrength * 20, \"%, \").concat(alpha, \")\");\n          } else {\n            // Background dimmed pixels\n            ctx.fillStyle = \"rgb(\".concat(gridColor.r, \", \").concat(gridColor.g, \", \").concat(gridColor.b, \")\");\n          }\n\n          // Only draw if visible enough (perf optimization)\n          if (fieldStrength > 0.05 || (i + j) % 2 === 0) {\n            // Draw slight background pattern even if no field\n            ctx.fillRect(px, py, pixelSize, pixelSize);\n          }\n        }\n      }\n    };\n    const animate = time => {\n      draw(time);\n      animationFrameId = requestAnimationFrame(animate);\n    };\n    const handleResize = () => {\n      init();\n    };\n    const handleMouseMove = e => {\n      const rect = canvas.getBoundingClientRect();\n      mouse.x = e.clientX - rect.left;\n      mouse.y = e.clientY - rect.top;\n    };\n    const handleMouseLeave = () => {\n      mouse.x = -1000;\n      mouse.y = -1000;\n    };\n    window.addEventListener('resize', handleResize);\n    window.addEventListener('mousemove', handleMouseMove);\n    window.addEventListener('mouseout', handleMouseLeave);\n    init();\n    animate(0);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      window.removeEventListener('mousemove', handleMouseMove);\n      window.removeEventListener('mouseout', handleMouseLeave);\n      cancelAnimationFrame(animationFrameId);\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      zIndex: 0,\n      pointerEvents: 'none'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 179,\n    columnNumber: 9\n  }, this);\n};\n_s(PixelBackground, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = PixelBackground;\nexport default PixelBackground;\nvar _c;\n$RefreshReg$(_c, \"PixelBackground\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","PixelBackground","_s","canvasRef","canvas","current","ctx","getContext","width","height","animationFrameId","pixelSize","gap","gridColor","r","g","b","agentCount","agents","hue","mouse","x","y","Agent","constructor","Math","random","vx","vy","radius","noiseOffset","update","time","sin","cos","centerX","centerY","dx","dy","dmx","dmy","distMouse","sqrt","repelRadius","force","init","window","innerWidth","innerHeight","length","i","push","draw","fillStyle","fillRect","forEach","agent","cols","ceil","rows","j","px","py","fieldStrength","dist","alpha","min","concat","animate","requestAnimationFrame","handleResize","handleMouseMove","e","rect","getBoundingClientRect","clientX","left","clientY","top","handleMouseLeave","addEventListener","removeEventListener","cancelAnimationFrame","ref","style","position","zIndex","pointerEvents","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/hishi/Documents/ポートフォリオ2026/portfolio/my-portfolio-2026/src/components/PixelBackground.js"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\r\n\r\nconst PixelBackground = () => {\r\n    const canvasRef = useRef(null);\r\n\r\n    useEffect(() => {\r\n        const canvas = canvasRef.current;\r\n        const ctx = canvas.getContext('2d');\r\n        let width, height;\r\n        let animationFrameId;\r\n\r\n        // Settings\r\n        const pixelSize = 25;\r\n        const gap = 2;\r\n        const gridColor = { r: 20, g: 20, b: 30 }; // Dark background\r\n\r\n        // Swarm settings\r\n        const agentCount = 12;\r\n        const agents = [];\r\n        let hue = 260; // Starting hue (Purple)\r\n\r\n        let mouse = { x: -1000, y: -1000 };\r\n\r\n        // Agent Class representing a \"cell\" of the living entity\r\n        class Agent {\r\n            constructor() {\r\n                this.x = width / 2 + (Math.random() - 0.5) * 200;\r\n                this.y = height / 2 + (Math.random() - 0.5) * 200;\r\n                this.vx = (Math.random() - 0.5) * 2;\r\n                this.vy = (Math.random() - 0.5) * 2;\r\n                this.radius = 100 + Math.random() * 100; // Influence radius\r\n                this.noiseOffset = Math.random() * 1000;\r\n            }\r\n\r\n            update(time) {\r\n                // 1. Organic Movement (Perlin-ish noise via sin/cos)\r\n                this.vx += Math.sin(time * 0.002 + this.noiseOffset) * 0.05;\r\n                this.vy += Math.cos(time * 0.002 + this.noiseOffset) * 0.05;\r\n\r\n                // 2. Cohesion (Attract to center of screen to keep the blob somewhat together)\r\n                const centerX = width / 2;\r\n                const centerY = height / 2;\r\n                const dx = centerX - this.x;\r\n                const dy = centerY - this.y;\r\n                this.vx += dx * 0.0001;\r\n                this.vy += dy * 0.0001;\r\n\r\n                // 3. Mouse Repulsion (Scattering)\r\n                const dmx = this.x - mouse.x;\r\n                const dmy = this.y - mouse.y;\r\n                const distMouse = Math.sqrt(dmx * dmx + dmy * dmy);\r\n                const repelRadius = 300;\r\n\r\n                if (distMouse < repelRadius) {\r\n                    const force = (repelRadius - distMouse) / repelRadius;\r\n                    this.vx += (dmx / distMouse) * force * 1.5;\r\n                    this.vy += (dmy / distMouse) * force * 1.5;\r\n                }\r\n\r\n                // Friction\r\n                this.vx *= 0.96;\r\n                this.vy *= 0.96;\r\n\r\n                // Move\r\n                this.x += this.vx;\r\n                this.y += this.vy;\r\n\r\n                // Boundary check (soft bounce)\r\n                if (this.x < 0) this.vx += 0.5;\r\n                if (this.x > width) this.vx -= 0.5;\r\n                if (this.y < 0) this.vy += 0.5;\r\n                if (this.y > height) this.vy -= 0.5;\r\n            }\r\n        }\r\n\r\n        const init = () => {\r\n            width = canvas.width = window.innerWidth;\r\n            height = canvas.height = window.innerHeight;\r\n\r\n            agents.length = 0;\r\n            for (let i = 0; i < agentCount; i++) {\r\n                agents.push(new Agent()); // Use the class properly\r\n            }\r\n        };\r\n\r\n        const draw = (time) => {\r\n            // Clear background\r\n            ctx.fillStyle = '#020205'; // Very dark background\r\n            ctx.fillRect(0, 0, width, height);\r\n\r\n            // Update Agents\r\n            agents.forEach(agent => agent.update(time));\r\n\r\n            // Cycle Hue\r\n            hue = (hue + 0.1) % 360;\r\n\r\n            // Draw Pixel Grid\r\n            const cols = Math.ceil(width / (pixelSize + gap));\r\n            const rows = Math.ceil(height / (pixelSize + gap));\r\n\r\n            for (let i = 0; i < cols; i++) {\r\n                for (let j = 0; j < rows; j++) {\r\n                    const px = i * (pixelSize + gap);\r\n                    const py = j * (pixelSize + gap);\r\n\r\n                    // Calculate Field Strength (Metaball-ish)\r\n                    let fieldStrength = 0;\r\n\r\n                    for (let agent of agents) {\r\n                        const dx = px - agent.x;\r\n                        const dy = py - agent.y;\r\n                        const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                        // Inverse square law-ish falloff for smooth blobs\r\n                        if (dist < agent.radius) {\r\n                            fieldStrength += (1 - dist / agent.radius);\r\n                        }\r\n                    }\r\n\r\n                    // Render Pixel based on strength\r\n                    if (fieldStrength > 0) {\r\n                        // Creating visual thresholding for the \"blob\" look\r\n                        // Power curve to sharpen edges slightly\r\n                        let alpha = Math.min(fieldStrength * 0.8, 0.9);\r\n\r\n                        // Color blending: Core is white/bright, edges are colored\r\n                        // Using HSL for continuous color cycling\r\n                        ctx.fillStyle = `hsla(${hue}, 80%, ${50 + fieldStrength * 20}%, ${alpha})`;\r\n                    } else {\r\n                        // Background dimmed pixels\r\n                        ctx.fillStyle = `rgb(${gridColor.r}, ${gridColor.g}, ${gridColor.b})`;\r\n                    }\r\n\r\n                    // Only draw if visible enough (perf optimization)\r\n                    if (fieldStrength > 0.05 || (i + j) % 2 === 0) {\r\n                        // Draw slight background pattern even if no field\r\n                        ctx.fillRect(px, py, pixelSize, pixelSize);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        const animate = (time) => {\r\n            draw(time);\r\n            animationFrameId = requestAnimationFrame(animate);\r\n        };\r\n\r\n        const handleResize = () => {\r\n            init();\r\n        };\r\n\r\n        const handleMouseMove = (e) => {\r\n            const rect = canvas.getBoundingClientRect();\r\n            mouse.x = e.clientX - rect.left;\r\n            mouse.y = e.clientY - rect.top;\r\n        };\r\n\r\n        const handleMouseLeave = () => {\r\n            mouse.x = -1000;\r\n            mouse.y = -1000;\r\n        }\r\n\r\n        window.addEventListener('resize', handleResize);\r\n        window.addEventListener('mousemove', handleMouseMove);\r\n        window.addEventListener('mouseout', handleMouseLeave);\r\n\r\n        init();\r\n        animate(0);\r\n\r\n        return () => {\r\n            window.removeEventListener('resize', handleResize);\r\n            window.removeEventListener('mousemove', handleMouseMove);\r\n            window.removeEventListener('mouseout', handleMouseLeave);\r\n            cancelAnimationFrame(animationFrameId);\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <canvas\r\n            ref={canvasRef}\r\n            style={{\r\n                position: 'absolute',\r\n                top: 0,\r\n                left: 0,\r\n                width: '100%',\r\n                height: '100%',\r\n                zIndex: 0,\r\n                pointerEvents: 'none'\r\n            }}\r\n        />\r\n    );\r\n};\r\n\r\nexport default PixelBackground;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}