{"ast":null,"code":"import { activeAnimations } from './animation-count.mjs';\nimport { statsBuffer } from './buffer.mjs';\nimport { frame, cancelFrame, frameData } from '../frameloop/frame.mjs';\nfunction record() {\n  const {\n    value\n  } = statsBuffer;\n  if (value === null) {\n    cancelFrame(record);\n    return;\n  }\n  value.frameloop.rate.push(frameData.delta);\n  value.animations.mainThread.push(activeAnimations.mainThread);\n  value.animations.waapi.push(activeAnimations.waapi);\n  value.animations.layout.push(activeAnimations.layout);\n}\nfunction mean(values) {\n  return values.reduce((acc, value) => acc + value, 0) / values.length;\n}\nfunction summarise(values) {\n  let calcAverage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mean;\n  if (values.length === 0) {\n    return {\n      min: 0,\n      max: 0,\n      avg: 0\n    };\n  }\n  return {\n    min: Math.min(...values),\n    max: Math.max(...values),\n    avg: calcAverage(values)\n  };\n}\nconst msToFps = ms => Math.round(1000 / ms);\nfunction clearStatsBuffer() {\n  statsBuffer.value = null;\n  statsBuffer.addProjectionMetrics = null;\n}\nfunction reportStats() {\n  const {\n    value\n  } = statsBuffer;\n  if (!value) {\n    throw new Error(\"Stats are not being measured\");\n  }\n  clearStatsBuffer();\n  cancelFrame(record);\n  const summary = {\n    frameloop: {\n      setup: summarise(value.frameloop.setup),\n      rate: summarise(value.frameloop.rate),\n      read: summarise(value.frameloop.read),\n      resolveKeyframes: summarise(value.frameloop.resolveKeyframes),\n      preUpdate: summarise(value.frameloop.preUpdate),\n      update: summarise(value.frameloop.update),\n      preRender: summarise(value.frameloop.preRender),\n      render: summarise(value.frameloop.render),\n      postRender: summarise(value.frameloop.postRender)\n    },\n    animations: {\n      mainThread: summarise(value.animations.mainThread),\n      waapi: summarise(value.animations.waapi),\n      layout: summarise(value.animations.layout)\n    },\n    layoutProjection: {\n      nodes: summarise(value.layoutProjection.nodes),\n      calculatedTargetDeltas: summarise(value.layoutProjection.calculatedTargetDeltas),\n      calculatedProjections: summarise(value.layoutProjection.calculatedProjections)\n    }\n  };\n  /**\n   * Convert the rate to FPS\n   */\n  const {\n    rate\n  } = summary.frameloop;\n  rate.min = msToFps(rate.min);\n  rate.max = msToFps(rate.max);\n  rate.avg = msToFps(rate.avg);\n  [rate.min, rate.max] = [rate.max, rate.min];\n  return summary;\n}\nfunction recordStats() {\n  if (statsBuffer.value) {\n    clearStatsBuffer();\n    throw new Error(\"Stats are already being measured\");\n  }\n  const newStatsBuffer = statsBuffer;\n  newStatsBuffer.value = {\n    frameloop: {\n      setup: [],\n      rate: [],\n      read: [],\n      resolveKeyframes: [],\n      preUpdate: [],\n      update: [],\n      preRender: [],\n      render: [],\n      postRender: []\n    },\n    animations: {\n      mainThread: [],\n      waapi: [],\n      layout: []\n    },\n    layoutProjection: {\n      nodes: [],\n      calculatedTargetDeltas: [],\n      calculatedProjections: []\n    }\n  };\n  newStatsBuffer.addProjectionMetrics = metrics => {\n    const {\n      layoutProjection\n    } = newStatsBuffer.value;\n    layoutProjection.nodes.push(metrics.nodes);\n    layoutProjection.calculatedTargetDeltas.push(metrics.calculatedTargetDeltas);\n    layoutProjection.calculatedProjections.push(metrics.calculatedProjections);\n  };\n  frame.postRender(record, true);\n  return reportStats;\n}\nexport { recordStats };","map":{"version":3,"names":["record","value","statsBuffer","cancelFrame","frameloop","rate","push","frameData","delta","animations","mainThread","activeAnimations","waapi","layout","mean","values","reduce","acc","length","summarise","calcAverage","arguments","undefined","min","max","avg","Math","msToFps","ms","round","clearStatsBuffer","addProjectionMetrics","reportStats","Error","summary","setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender","layoutProjection","nodes","calculatedTargetDeltas","calculatedProjections","recordStats","newStatsBuffer","metrics","frame"],"sources":["C:\\Users\\hishi\\Documents\\ポートフォリオ2026\\portfolio\\my-portfolio-2026\\node_modules\\motion-dom\\src\\stats\\index.ts"],"sourcesContent":["import { cancelFrame, frame, frameData } from \"../frameloop\"\nimport { activeAnimations } from \"./animation-count\"\nimport { ActiveStatsBuffer, statsBuffer } from \"./buffer\"\nimport { StatsSummary, Summary } from \"./types\"\n\nfunction record() {\n    const { value } = statsBuffer\n\n    if (value === null) {\n        cancelFrame(record)\n        return\n    }\n\n    value.frameloop.rate.push(frameData.delta)\n    value.animations.mainThread.push(activeAnimations.mainThread)\n    value.animations.waapi.push(activeAnimations.waapi)\n    value.animations.layout.push(activeAnimations.layout)\n}\n\nfunction mean(values: number[]) {\n    return values.reduce((acc, value) => acc + value, 0) / values.length\n}\n\nfunction summarise(\n    values: number[],\n    calcAverage: (allValues: number[]) => number = mean\n): Summary {\n    if (values.length === 0) {\n        return {\n            min: 0,\n            max: 0,\n            avg: 0,\n        }\n    }\n\n    return {\n        min: Math.min(...values),\n        max: Math.max(...values),\n        avg: calcAverage(values),\n    }\n}\n\nconst msToFps = (ms: number) => Math.round(1000 / ms)\n\nfunction clearStatsBuffer() {\n    statsBuffer.value = null\n    statsBuffer.addProjectionMetrics = null\n}\n\nfunction reportStats(): StatsSummary {\n    const { value } = statsBuffer\n\n    if (!value) {\n        throw new Error(\"Stats are not being measured\")\n    }\n\n    clearStatsBuffer()\n    cancelFrame(record)\n\n    const summary = {\n        frameloop: {\n            setup: summarise(value.frameloop.setup),\n            rate: summarise(value.frameloop.rate),\n            read: summarise(value.frameloop.read),\n            resolveKeyframes: summarise(value.frameloop.resolveKeyframes),\n            preUpdate: summarise(value.frameloop.preUpdate),\n            update: summarise(value.frameloop.update),\n            preRender: summarise(value.frameloop.preRender),\n            render: summarise(value.frameloop.render),\n            postRender: summarise(value.frameloop.postRender),\n        },\n        animations: {\n            mainThread: summarise(value.animations.mainThread),\n            waapi: summarise(value.animations.waapi),\n            layout: summarise(value.animations.layout),\n        },\n        layoutProjection: {\n            nodes: summarise(value.layoutProjection.nodes),\n            calculatedTargetDeltas: summarise(\n                value.layoutProjection.calculatedTargetDeltas\n            ),\n            calculatedProjections: summarise(\n                value.layoutProjection.calculatedProjections\n            ),\n        },\n    }\n\n    /**\n     * Convert the rate to FPS\n     */\n    const { rate } = summary.frameloop\n    rate.min = msToFps(rate.min)\n    rate.max = msToFps(rate.max)\n    rate.avg = msToFps(rate.avg)\n    // Swap these as the min and max are inverted when converted to FPS\n    ;[rate.min, rate.max] = [rate.max, rate.min]\n\n    return summary\n}\n\nexport function recordStats() {\n    if (statsBuffer.value) {\n        clearStatsBuffer()\n        throw new Error(\"Stats are already being measured\")\n    }\n\n    const newStatsBuffer = statsBuffer as unknown as ActiveStatsBuffer\n\n    newStatsBuffer.value = {\n        frameloop: {\n            setup: [],\n            rate: [],\n            read: [],\n            resolveKeyframes: [],\n            preUpdate: [],\n            update: [],\n            preRender: [],\n            render: [],\n            postRender: [],\n        },\n        animations: {\n            mainThread: [],\n            waapi: [],\n            layout: [],\n        },\n        layoutProjection: {\n            nodes: [],\n            calculatedTargetDeltas: [],\n            calculatedProjections: [],\n        },\n    }\n\n    newStatsBuffer.addProjectionMetrics = (metrics) => {\n        const { layoutProjection } = newStatsBuffer.value\n        layoutProjection.nodes.push(metrics.nodes)\n        layoutProjection.calculatedTargetDeltas.push(\n            metrics.calculatedTargetDeltas\n        )\n        layoutProjection.calculatedProjections.push(\n            metrics.calculatedProjections\n        )\n    }\n\n    frame.postRender(record, true)\n\n    return reportStats\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}