{"ast":null,"code":"import _objectSpread from \"C:/Users/hishi/Documents/\\u30DD\\u30FC\\u30C8\\u30D5\\u30A9\\u30EA\\u30AA2026/portfolio/my-portfolio-2026/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { invariant, pipe, clamp, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { activeAnimations } from '../stats/animation-count.mjs';\nimport { mix } from '../utils/mix/index.mjs';\nimport { frameloopDriver } from './drivers/frame.mjs';\nimport { inertia } from './generators/inertia.mjs';\nimport { keyframes } from './generators/keyframes.mjs';\nimport { calcGeneratorDuration } from './generators/utils/calc-duration.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nconst percentToProgress = percent => percent / 100;\nclass JSAnimation extends WithPromise {\n  constructor(options) {\n    super();\n    this.state = \"idle\";\n    this.startTime = null;\n    this.isStopped = false;\n    /**\n     * The current time of the animation.\n     */\n    this.currentTime = 0;\n    /**\n     * The time at which the animation was paused.\n     */\n    this.holdTime = null;\n    /**\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n     */\n    this.playbackSpeed = 1;\n    /**\n     * This method is bound to the instance to fix a pattern where\n     * animation.stop is returned as a reference from a useEffect.\n     */\n    this.stop = () => {\n      var _this$options$onStop, _this$options;\n      const {\n        motionValue\n      } = this.options;\n      if (motionValue && motionValue.updatedAt !== time.now()) {\n        this.tick(time.now());\n      }\n      this.isStopped = true;\n      if (this.state === \"idle\") return;\n      this.teardown();\n      (_this$options$onStop = (_this$options = this.options).onStop) === null || _this$options$onStop === void 0 || _this$options$onStop.call(_this$options);\n    };\n    activeAnimations.mainThread++;\n    this.options = options;\n    this.initAnimation();\n    this.play();\n    if (options.autoplay === false) this.pause();\n  }\n  initAnimation() {\n    const {\n      options\n    } = this;\n    replaceTransitionType(options);\n    const {\n      type = keyframes,\n      repeat = 0,\n      repeatDelay = 0,\n      repeatType,\n      velocity = 0\n    } = options;\n    let {\n      keyframes: keyframes$1\n    } = options;\n    const generatorFactory = type || keyframes;\n    if (process.env.NODE_ENV !== \"production\" && generatorFactory !== keyframes) {\n      invariant(keyframes$1.length <= 2, \"Only two keyframes currently supported with spring and inertia animations. Trying to animate \".concat(keyframes$1), \"spring-two-frames\");\n    }\n    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n      this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n      keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory(_objectSpread(_objectSpread({}, options), {}, {\n      keyframes: keyframes$1\n    }));\n    /**\n     * If we have a mirror repeat type we need to create a second generator that outputs the\n     * mirrored (not reversed) animation and later ping pong between the two generators.\n     */\n    if (repeatType === \"mirror\") {\n      this.mirroredGenerator = generatorFactory(_objectSpread(_objectSpread({}, options), {}, {\n        keyframes: [...keyframes$1].reverse(),\n        velocity: -velocity\n      }));\n    }\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null) {\n      generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n    const {\n      calculatedDuration\n    } = generator;\n    this.calculatedDuration = calculatedDuration;\n    this.resolvedDuration = calculatedDuration + repeatDelay;\n    this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;\n    this.generator = generator;\n  }\n  updateTime(timestamp) {\n    const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;\n    // Update currentTime\n    if (this.holdTime !== null) {\n      this.currentTime = this.holdTime;\n    } else {\n      // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n      // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n      // example.\n      this.currentTime = animationTime;\n    }\n  }\n  tick(timestamp) {\n    let sample = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      generator,\n      totalDuration,\n      mixKeyframes,\n      mirroredGenerator,\n      resolvedDuration,\n      calculatedDuration\n    } = this;\n    if (this.startTime === null) return generator.next(0);\n    const {\n      delay = 0,\n      keyframes,\n      repeat,\n      repeatType,\n      repeatDelay,\n      type,\n      onUpdate,\n      finalKeyframe\n    } = this.options;\n    /**\n     * requestAnimationFrame timestamps can come through as lower than\n     * the startTime as set by performance.now(). Here we prevent this,\n     * though in the future it could be possible to make setting startTime\n     * a pending operation that gets resolved here.\n     */\n    if (this.speed > 0) {\n      this.startTime = Math.min(this.startTime, timestamp);\n    } else if (this.speed < 0) {\n      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n    }\n    if (sample) {\n      this.currentTime = timestamp;\n    } else {\n      this.updateTime(timestamp);\n    }\n    // Rebase on delay\n    const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);\n    const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n    this.currentTime = Math.max(timeWithoutDelay, 0);\n    // If this animation has finished, set the current time  to the total duration.\n    if (this.state === \"finished\" && this.holdTime === null) {\n      this.currentTime = totalDuration;\n    }\n    let elapsed = this.currentTime;\n    let frameGenerator = generator;\n    if (repeat) {\n      /**\n       * Get the current progress (0-1) of the animation. If t is >\n       * than duration we'll get values like 2.5 (midway through the\n       * third iteration)\n       */\n      const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n      /**\n       * Get the current iteration (0 indexed). For instance the floor of\n       * 2.5 is 2.\n       */\n      let currentIteration = Math.floor(progress);\n      /**\n       * Get the current progress of the iteration by taking the remainder\n       * so 2.5 is 0.5 through iteration 2\n       */\n      let iterationProgress = progress % 1.0;\n      /**\n       * If iteration progress is 1 we count that as the end\n       * of the previous iteration.\n       */\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\n       * Reverse progress if we're not running in \"normal\" direction\n       */\n      const isOddIteration = Boolean(currentIteration % 2);\n      if (isOddIteration) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n    }\n    /**\n     * If we're in negative time, set state as the initial keyframe.\n     * This prevents delay: x, duration: 0 animations from finishing\n     * instantly.\n     */\n    const state = isInDelayPhase ? {\n      done: false,\n      value: keyframes[0]\n    } : frameGenerator.next(elapsed);\n    if (mixKeyframes) {\n      state.value = mixKeyframes(state.value);\n    }\n    let {\n      done\n    } = state;\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;\n    }\n    const isAnimationFinished = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && done);\n    // TODO: The exception for inertia could be cleaner here\n    if (isAnimationFinished && type !== inertia) {\n      state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n    }\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n    if (isAnimationFinished) {\n      this.finish();\n    }\n    return state;\n  }\n  /**\n   * Allows the returned animation to be awaited or promise-chained. Currently\n   * resolves when the animation finishes at all but in a future update could/should\n   * reject if its cancels.\n   */\n  then(resolve, reject) {\n    return this.finished.then(resolve, reject);\n  }\n  get duration() {\n    return millisecondsToSeconds(this.calculatedDuration);\n  }\n  get iterationDuration() {\n    const {\n      delay = 0\n    } = this.options || {};\n    return this.duration + millisecondsToSeconds(delay);\n  }\n  get time() {\n    return millisecondsToSeconds(this.currentTime);\n  }\n  set time(newTime) {\n    var _this$driver;\n    newTime = secondsToMilliseconds(newTime);\n    this.currentTime = newTime;\n    if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {\n      this.holdTime = newTime;\n    } else if (this.driver) {\n      this.startTime = this.driver.now() - newTime / this.playbackSpeed;\n    }\n    (_this$driver = this.driver) === null || _this$driver === void 0 || _this$driver.start(false);\n  }\n  get speed() {\n    return this.playbackSpeed;\n  }\n  set speed(newSpeed) {\n    this.updateTime(time.now());\n    const hasChanged = this.playbackSpeed !== newSpeed;\n    this.playbackSpeed = newSpeed;\n    if (hasChanged) {\n      this.time = millisecondsToSeconds(this.currentTime);\n    }\n  }\n  play() {\n    var _this$options$onPlay, _this$options2;\n    if (this.isStopped) return;\n    const {\n      driver = frameloopDriver,\n      startTime\n    } = this.options;\n    if (!this.driver) {\n      this.driver = driver(timestamp => this.tick(timestamp));\n    }\n    (_this$options$onPlay = (_this$options2 = this.options).onPlay) === null || _this$options$onPlay === void 0 || _this$options$onPlay.call(_this$options2);\n    const now = this.driver.now();\n    if (this.state === \"finished\") {\n      this.updateFinished();\n      this.startTime = now;\n    } else if (this.holdTime !== null) {\n      this.startTime = now - this.holdTime;\n    } else if (!this.startTime) {\n      this.startTime = startTime !== null && startTime !== void 0 ? startTime : now;\n    }\n    if (this.state === \"finished\" && this.speed < 0) {\n      this.startTime += this.calculatedDuration;\n    }\n    this.holdTime = null;\n    /**\n     * Set playState to running only after we've used it in\n     * the previous logic.\n     */\n    this.state = \"running\";\n    this.driver.start();\n  }\n  pause() {\n    this.state = \"paused\";\n    this.updateTime(time.now());\n    this.holdTime = this.currentTime;\n  }\n  complete() {\n    if (this.state !== \"running\") {\n      this.play();\n    }\n    this.state = \"finished\";\n    this.holdTime = null;\n  }\n  finish() {\n    var _this$options$onCompl, _this$options3;\n    this.notifyFinished();\n    this.teardown();\n    this.state = \"finished\";\n    (_this$options$onCompl = (_this$options3 = this.options).onComplete) === null || _this$options$onCompl === void 0 || _this$options$onCompl.call(_this$options3);\n  }\n  cancel() {\n    var _this$options$onCance, _this$options4;\n    this.holdTime = null;\n    this.startTime = 0;\n    this.tick(0);\n    this.teardown();\n    (_this$options$onCance = (_this$options4 = this.options).onCancel) === null || _this$options$onCance === void 0 || _this$options$onCance.call(_this$options4);\n  }\n  teardown() {\n    this.state = \"idle\";\n    this.stopDriver();\n    this.startTime = this.holdTime = null;\n    activeAnimations.mainThread--;\n  }\n  stopDriver() {\n    if (!this.driver) return;\n    this.driver.stop();\n    this.driver = undefined;\n  }\n  sample(sampleTime) {\n    this.startTime = 0;\n    return this.tick(sampleTime, true);\n  }\n  attachTimeline(timeline) {\n    var _this$driver2;\n    if (this.options.allowFlatten) {\n      this.options.type = \"keyframes\";\n      this.options.ease = \"linear\";\n      this.initAnimation();\n    }\n    (_this$driver2 = this.driver) === null || _this$driver2 === void 0 || _this$driver2.stop();\n    return timeline.observe(this);\n  }\n}\n// Legacy function support\nfunction animateValue(options) {\n  return new JSAnimation(options);\n}\nexport { JSAnimation, animateValue };","map":{"version":3,"names":["percentToProgress","percent","JSAnimation","WithPromise","constructor","options","state","startTime","isStopped","currentTime","holdTime","playbackSpeed","stop","_this$options$onStop","_this$options","motionValue","updatedAt","time","now","tick","teardown","onStop","call","activeAnimations","mainThread","initAnimation","play","autoplay","pause","replaceTransitionType","type","keyframes","repeat","repeatDelay","repeatType","velocity","keyframes$1","generatorFactory","process","env","NODE_ENV","invariant","length","concat","mixKeyframes","pipe","mix","generator","_objectSpread","mirroredGenerator","reverse","calculatedDuration","calcGeneratorDuration","resolvedDuration","totalDuration","updateTime","timestamp","animationTime","Math","round","sample","arguments","undefined","next","delay","onUpdate","finalKeyframe","speed","min","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","isOddIteration","Boolean","clamp","done","value","isAnimationFinished","inertia","getFinalKeyframe","finish","then","resolve","reject","finished","duration","millisecondsToSeconds","iterationDuration","newTime","_this$driver","secondsToMilliseconds","driver","start","newSpeed","hasChanged","_this$options$onPlay","_this$options2","frameloopDriver","onPlay","updateFinished","complete","_this$options$onCompl","_this$options3","notifyFinished","onComplete","cancel","_this$options$onCance","_this$options4","onCancel","stopDriver","sampleTime","attachTimeline","timeline","_this$driver2","allowFlatten","ease","observe","animateValue"],"sources":["C:\\Users\\hishi\\Documents\\ポートフォリオ2026\\portfolio\\my-portfolio-2026\\node_modules\\motion-dom\\src\\animation\\JSAnimation.ts"],"sourcesContent":["import {\n    clamp,\n    invariant,\n    millisecondsToSeconds,\n    pipe,\n    secondsToMilliseconds,\n} from \"motion-utils\"\nimport { time } from \"../frameloop/sync-time\"\nimport { activeAnimations } from \"../stats/animation-count\"\nimport { mix } from \"../utils/mix\"\nimport { Mixer } from \"../utils/mix/types\"\nimport { frameloopDriver } from \"./drivers/frame\"\nimport { DriverControls } from \"./drivers/types\"\nimport { inertia } from \"./generators/inertia\"\nimport { keyframes as keyframesGenerator } from \"./generators/keyframes\"\nimport { calcGeneratorDuration } from \"./generators/utils/calc-duration\"\nimport { getFinalKeyframe } from \"./keyframes/get-final\"\nimport {\n    AnimationPlaybackControlsWithThen,\n    AnimationState,\n    GeneratorFactory,\n    KeyframeGenerator,\n    TimelineWithFallback,\n    ValueAnimationOptions,\n} from \"./types\"\nimport { replaceTransitionType } from \"./utils/replace-transition-type\"\nimport { WithPromise } from \"./utils/WithPromise\"\n\nconst percentToProgress = (percent: number) => percent / 100\n\nexport class JSAnimation<T extends number | string>\n    extends WithPromise\n    implements AnimationPlaybackControlsWithThen\n{\n    state: AnimationPlayState = \"idle\"\n\n    startTime: number | null = null\n\n    /**\n     * The driver that's controlling the animation loop. Normally this is a requestAnimationFrame loop\n     * but in tests we can pass in a synchronous loop.\n     */\n    private driver?: DriverControls\n\n    private isStopped = false\n\n    private generator: KeyframeGenerator<T>\n\n    private calculatedDuration: number\n\n    private resolvedDuration: number\n\n    private totalDuration: number\n\n    private options: ValueAnimationOptions<T>\n\n    /**\n     * The current time of the animation.\n     */\n    private currentTime: number = 0\n\n    /**\n     * The time at which the animation was paused.\n     */\n    private holdTime: number | null = null\n\n    /**\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n     */\n    private playbackSpeed = 1\n\n    /*\n     * If our generator doesn't support mixing numbers, we need to replace keyframes with\n     * [0, 100] and then make a function that maps that to the actual keyframes.\n     *\n     * 100 is chosen instead of 1 as it works nicer with spring animations.\n     */\n    private mixKeyframes: Mixer<T> | undefined\n\n    private mirroredGenerator: KeyframeGenerator<T> | undefined\n\n    constructor(options: ValueAnimationOptions<T>) {\n        super()\n        activeAnimations.mainThread++\n\n        this.options = options\n        this.initAnimation()\n        this.play()\n\n        if (options.autoplay === false) this.pause()\n    }\n\n    initAnimation() {\n        const { options } = this\n\n        replaceTransitionType(options)\n\n        const {\n            type = keyframesGenerator,\n            repeat = 0,\n            repeatDelay = 0,\n            repeatType,\n            velocity = 0,\n        } = options\n        let { keyframes } = options\n\n        const generatorFactory =\n            (type as GeneratorFactory) || keyframesGenerator\n\n        if (\n            process.env.NODE_ENV !== \"production\" &&\n            generatorFactory !== keyframesGenerator\n        ) {\n            invariant(\n                keyframes.length <= 2,\n                `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes}`,\n                \"spring-two-frames\"\n            )\n        }\n\n        if (\n            generatorFactory !== keyframesGenerator &&\n            typeof keyframes[0] !== \"number\"\n        ) {\n            this.mixKeyframes = pipe(\n                percentToProgress,\n                mix(keyframes[0], keyframes[1])\n            ) as (t: number) => T\n\n            keyframes = [0 as T, 100 as T]\n        }\n\n        const generator = generatorFactory({ ...options, keyframes })\n\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            this.mirroredGenerator = generatorFactory({\n                ...options,\n                keyframes: [...keyframes].reverse(),\n                velocity: -velocity,\n            })\n        }\n\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator)\n        }\n\n        const { calculatedDuration } = generator\n        this.calculatedDuration = calculatedDuration\n        this.resolvedDuration = calculatedDuration + repeatDelay\n        this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay\n        this.generator = generator\n    }\n\n    updateTime(timestamp: number) {\n        const animationTime =\n            Math.round(timestamp - this.startTime!) * this.playbackSpeed\n\n        // Update currentTime\n        if (this.holdTime !== null) {\n            this.currentTime = this.holdTime\n        } else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime = animationTime\n        }\n    }\n\n    tick(timestamp: number, sample = false) {\n        const {\n            generator,\n            totalDuration,\n            mixKeyframes,\n            mirroredGenerator,\n            resolvedDuration,\n            calculatedDuration,\n        } = this\n\n        if (this.startTime === null) return generator.next(0)\n\n        const {\n            delay = 0,\n            keyframes,\n            repeat,\n            repeatType,\n            repeatDelay,\n            type,\n            onUpdate,\n            finalKeyframe,\n        } = this.options\n\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp)\n        } else if (this.speed < 0) {\n            this.startTime = Math.min(\n                timestamp - totalDuration / this.speed,\n                this.startTime\n            )\n        }\n\n        if (sample) {\n            this.currentTime = timestamp\n        } else {\n            this.updateTime(timestamp)\n        }\n\n        // Rebase on delay\n        const timeWithoutDelay =\n            this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1)\n        const isInDelayPhase =\n            this.playbackSpeed >= 0\n                ? timeWithoutDelay < 0\n                : timeWithoutDelay > totalDuration\n        this.currentTime = Math.max(timeWithoutDelay, 0)\n\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration\n        }\n\n        let elapsed = this.currentTime\n        let frameGenerator = generator\n\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress =\n                Math.min(this.currentTime, totalDuration) / resolvedDuration\n\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress)\n\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0\n\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1\n            }\n\n            iterationProgress === 1 && currentIteration--\n\n            currentIteration = Math.min(currentIteration, repeat + 1)\n\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n\n            const isOddIteration = Boolean(currentIteration % 2)\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration\n                    }\n                } else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator!\n                }\n            }\n\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration\n        }\n\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed)\n\n        if (mixKeyframes) {\n            state.value = mixKeyframes(state.value as number)\n        }\n\n        let { done } = state\n\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.playbackSpeed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0\n        }\n\n        const isAnimationFinished =\n            this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done))\n\n        // TODO: The exception for inertia could be cleaner here\n        if (isAnimationFinished && type !== inertia) {\n            state.value = getFinalKeyframe(\n                keyframes,\n                this.options,\n                finalKeyframe,\n                this.speed\n            )\n        }\n\n        if (onUpdate) {\n            onUpdate(state.value)\n        }\n\n        if (isAnimationFinished) {\n            this.finish()\n        }\n\n        return state\n    }\n\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve: VoidFunction, reject?: VoidFunction) {\n        return this.finished.then(resolve, reject)\n    }\n\n    get duration() {\n        return millisecondsToSeconds(this.calculatedDuration)\n    }\n\n    get iterationDuration() {\n        const { delay = 0 } = this.options || {}\n        return this.duration + millisecondsToSeconds(delay)\n    }\n\n    get time() {\n        return millisecondsToSeconds(this.currentTime)\n    }\n\n    set time(newTime: number) {\n        newTime = secondsToMilliseconds(newTime)\n        this.currentTime = newTime\n\n        if (\n            this.startTime === null ||\n            this.holdTime !== null ||\n            this.playbackSpeed === 0\n        ) {\n            this.holdTime = newTime\n        } else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.playbackSpeed\n        }\n\n        this.driver?.start(false)\n    }\n\n    get speed() {\n        return this.playbackSpeed\n    }\n\n    set speed(newSpeed: number) {\n        this.updateTime(time.now())\n        const hasChanged = this.playbackSpeed !== newSpeed\n        this.playbackSpeed = newSpeed\n\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime)\n        }\n    }\n\n    play() {\n        if (this.isStopped) return\n\n        const { driver = frameloopDriver, startTime } = this.options\n\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp))\n        }\n\n        this.options.onPlay?.()\n\n        const now = this.driver.now()\n\n        if (this.state === \"finished\") {\n            this.updateFinished()\n            this.startTime = now\n        } else if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime\n        } else if (!this.startTime) {\n            this.startTime = startTime ?? now\n        }\n\n        if (this.state === \"finished\" && this.speed < 0) {\n            this.startTime += this.calculatedDuration\n        }\n\n        this.holdTime = null\n\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\"\n\n        this.driver.start()\n    }\n\n    pause() {\n        this.state = \"paused\"\n        this.updateTime(time.now())\n        this.holdTime = this.currentTime\n    }\n\n    /**\n     * This method is bound to the instance to fix a pattern where\n     * animation.stop is returned as a reference from a useEffect.\n     */\n    stop = () => {\n        const { motionValue } = this.options\n        if (motionValue && motionValue.updatedAt !== time.now()) {\n            this.tick(time.now())\n        }\n\n        this.isStopped = true\n        if (this.state === \"idle\") return\n        this.teardown()\n        this.options.onStop?.()\n    }\n\n    complete() {\n        if (this.state !== \"running\") {\n            this.play()\n        }\n\n        this.state = \"finished\"\n        this.holdTime = null\n    }\n\n    finish() {\n        this.notifyFinished()\n        this.teardown()\n        this.state = \"finished\"\n\n        this.options.onComplete?.()\n    }\n\n    cancel() {\n        this.holdTime = null\n        this.startTime = 0\n        this.tick(0)\n        this.teardown()\n        this.options.onCancel?.()\n    }\n\n    private teardown() {\n        this.state = \"idle\"\n        this.stopDriver()\n        this.startTime = this.holdTime = null\n        activeAnimations.mainThread--\n    }\n\n    private stopDriver() {\n        if (!this.driver) return\n        this.driver.stop()\n        this.driver = undefined\n    }\n\n    sample(sampleTime: number): AnimationState<T> {\n        this.startTime = 0\n        return this.tick(sampleTime, true)\n    }\n\n    attachTimeline(timeline: TimelineWithFallback): VoidFunction {\n        if (this.options.allowFlatten) {\n            this.options.type = \"keyframes\"\n            this.options.ease = \"linear\"\n            this.initAnimation()\n        }\n\n        this.driver?.stop()\n        return timeline.observe(this)\n    }\n}\n\n// Legacy function support\nexport function animateValue<T extends number | string>(\n    options: ValueAnimationOptions<T>\n) {\n    return new JSAnimation(options)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}