{"ast":null,"code":"import _objectSpread from \"C:/Users/hishi/Documents/\\u30DD\\u30FC\\u30C8\\u30D5\\u30A9\\u30EA\\u30AA2026/portfolio/my-portfolio-2026/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/hishi/Documents/\\u30DD\\u30FC\\u30C8\\u30D5\\u30A9\\u30EA\\u30AA2026/portfolio/my-portfolio-2026/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"autoplay\", \"delay\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\", \"keyframes\", \"name\", \"motionValue\", \"element\"];\nimport { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { makeAnimationInstant } from './utils/make-animation-instant.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass AsyncMotionValueAnimation extends WithPromise {\n  constructor(_ref) {\n    var _this$keyframeResolve2;\n    let {\n        autoplay = true,\n        delay = 0,\n        type = \"keyframes\",\n        repeat = 0,\n        repeatDelay = 0,\n        repeatType = \"loop\",\n        keyframes,\n        name,\n        motionValue,\n        element\n      } = _ref,\n      options = _objectWithoutProperties(_ref, _excluded);\n    super();\n    /**\n     * Bound to support return animation.stop pattern\n     */\n    this.stop = () => {\n      var _this$keyframeResolve;\n      if (this._animation) {\n        var _this$stopTimeline;\n        this._animation.stop();\n        (_this$stopTimeline = this.stopTimeline) === null || _this$stopTimeline === void 0 || _this$stopTimeline.call(this);\n      }\n      (_this$keyframeResolve = this.keyframeResolver) === null || _this$keyframeResolve === void 0 || _this$keyframeResolve.cancel();\n    };\n    this.createdAt = time.now();\n    const optionsWithDefaults = _objectSpread({\n      autoplay,\n      delay,\n      type,\n      repeat,\n      repeatDelay,\n      repeatType,\n      name,\n      motionValue,\n      element\n    }, options);\n    const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n    this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n    (_this$keyframeResolve2 = this.keyframeResolver) === null || _this$keyframeResolve2 === void 0 || _this$keyframeResolve2.scheduleResolve();\n  }\n  onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n    var _resolvedOptions$moti;\n    this.keyframeResolver = undefined;\n    const {\n      name,\n      type,\n      velocity,\n      delay,\n      isHandoff,\n      onUpdate\n    } = options;\n    this.resolvedAt = time.now();\n    /**\n     * If we can't animate this value with the resolved keyframes\n     * then we should complete it immediately.\n     */\n    if (!canAnimate(keyframes, name, type, velocity)) {\n      if (MotionGlobalConfig.instantAnimations || !delay) {\n        onUpdate === null || onUpdate === void 0 || onUpdate(getFinalKeyframe(keyframes, options, finalKeyframe));\n      }\n      keyframes[0] = keyframes[keyframes.length - 1];\n      makeAnimationInstant(options);\n      options.repeat = 0;\n    }\n    /**\n     * Resolve startTime for the animation.\n     *\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first committed frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : undefined;\n    const resolvedOptions = _objectSpread(_objectSpread({\n      startTime,\n      finalKeyframe\n    }, options), {}, {\n      keyframes\n    });\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    const useWaapi = !isHandoff && supportsBrowserAnimation(resolvedOptions);\n    const element = (_resolvedOptions$moti = resolvedOptions.motionValue) === null || _resolvedOptions$moti === void 0 || (_resolvedOptions$moti = _resolvedOptions$moti.owner) === null || _resolvedOptions$moti === void 0 ? void 0 : _resolvedOptions$moti.current;\n    const animation = useWaapi ? new NativeAnimationExtended(_objectSpread(_objectSpread({}, resolvedOptions), {}, {\n      element\n    })) : new JSAnimation(resolvedOptions);\n    animation.finished.then(() => {\n      this.notifyFinished();\n    }).catch(noop);\n    if (this.pendingTimeline) {\n      this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n      this.pendingTimeline = undefined;\n    }\n    this._animation = animation;\n  }\n  get finished() {\n    if (!this._animation) {\n      return this._finished;\n    } else {\n      return this.animation.finished;\n    }\n  }\n  then(onResolve, _onReject) {\n    return this.finished.finally(onResolve).then(() => {});\n  }\n  get animation() {\n    if (!this._animation) {\n      var _this$keyframeResolve3;\n      (_this$keyframeResolve3 = this.keyframeResolver) === null || _this$keyframeResolve3 === void 0 || _this$keyframeResolve3.resume();\n      flushKeyframeResolvers();\n    }\n    return this._animation;\n  }\n  get duration() {\n    return this.animation.duration;\n  }\n  get iterationDuration() {\n    return this.animation.iterationDuration;\n  }\n  get time() {\n    return this.animation.time;\n  }\n  set time(newTime) {\n    this.animation.time = newTime;\n  }\n  get speed() {\n    return this.animation.speed;\n  }\n  get state() {\n    return this.animation.state;\n  }\n  set speed(newSpeed) {\n    this.animation.speed = newSpeed;\n  }\n  get startTime() {\n    return this.animation.startTime;\n  }\n  attachTimeline(timeline) {\n    if (this._animation) {\n      this.stopTimeline = this.animation.attachTimeline(timeline);\n    } else {\n      this.pendingTimeline = timeline;\n    }\n    return () => this.stop();\n  }\n  play() {\n    this.animation.play();\n  }\n  pause() {\n    this.animation.pause();\n  }\n  complete() {\n    this.animation.complete();\n  }\n  cancel() {\n    var _this$keyframeResolve4;\n    if (this._animation) {\n      this.animation.cancel();\n    }\n    (_this$keyframeResolve4 = this.keyframeResolver) === null || _this$keyframeResolve4 === void 0 || _this$keyframeResolve4.cancel();\n  }\n}\nexport { AsyncMotionValueAnimation };","map":{"version":3,"names":["MAX_RESOLVE_DELAY","AsyncMotionValueAnimation","WithPromise","constructor","_ref","_this$keyframeResolve2","autoplay","delay","type","repeat","repeatDelay","repeatType","keyframes","name","motionValue","element","options","_objectWithoutProperties","_excluded","stop","_this$keyframeResolve","_animation","_this$stopTimeline","stopTimeline","call","keyframeResolver","cancel","createdAt","time","now","optionsWithDefaults","_objectSpread","KeyframeResolver$1","KeyframeResolver","resolvedKeyframes","finalKeyframe","forced","onKeyframesResolved","scheduleResolve","sync","_resolvedOptions$moti","undefined","velocity","isHandoff","onUpdate","resolvedAt","canAnimate","MotionGlobalConfig","instantAnimations","getFinalKeyframe","length","makeAnimationInstant","startTime","resolvedOptions","useWaapi","supportsBrowserAnimation","owner","current","animation","NativeAnimationExtended","JSAnimation","finished","then","notifyFinished","catch","noop","pendingTimeline","attachTimeline","_finished","onResolve","_onReject","finally","_this$keyframeResolve3","resume","flushKeyframeResolvers","duration","iterationDuration","newTime","speed","state","newSpeed","timeline","play","pause","complete","_this$keyframeResolve4"],"sources":["C:\\Users\\hishi\\Documents\\ポートフォリオ2026\\portfolio\\my-portfolio-2026\\node_modules\\motion-dom\\src\\animation\\AsyncMotionValueAnimation.ts"],"sourcesContent":["import { MotionGlobalConfig, noop } from \"motion-utils\"\nimport { time } from \"../frameloop/sync-time\"\nimport { JSAnimation } from \"./JSAnimation\"\nimport { getFinalKeyframe } from \"./keyframes/get-final\"\nimport {\n    KeyframeResolver as DefaultKeyframeResolver,\n    flushKeyframeResolvers,\n    ResolvedKeyframes,\n} from \"./keyframes/KeyframesResolver\"\nimport { NativeAnimationExtended } from \"./NativeAnimationExtended\"\nimport {\n    AnimationPlaybackControls,\n    AnyResolvedKeyframe,\n    TimelineWithFallback,\n    ValueAnimationOptions,\n} from \"./types\"\nimport { canAnimate } from \"./utils/can-animate\"\nimport { makeAnimationInstant } from \"./utils/make-animation-instant\"\nimport { WithPromise } from \"./utils/WithPromise\"\nimport { supportsBrowserAnimation } from \"./waapi/supports/waapi\"\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40\n\ntype OptionsWithoutKeyframes<T extends AnyResolvedKeyframe> = Omit<\n    ValueAnimationOptions<T>,\n    \"keyframes\"\n>\n\nexport class AsyncMotionValueAnimation<T extends AnyResolvedKeyframe>\n    extends WithPromise\n    implements AnimationPlaybackControls\n{\n    private createdAt: number\n\n    private resolvedAt: number | undefined\n\n    private _animation: AnimationPlaybackControls | undefined\n\n    private pendingTimeline: TimelineWithFallback | undefined\n\n    private keyframeResolver: DefaultKeyframeResolver | undefined\n\n    private stopTimeline: VoidFunction | undefined\n\n    constructor({\n        autoplay = true,\n        delay = 0,\n        type = \"keyframes\",\n        repeat = 0,\n        repeatDelay = 0,\n        repeatType = \"loop\",\n        keyframes,\n        name,\n        motionValue,\n        element,\n        ...options\n    }: ValueAnimationOptions<T>) {\n        super()\n\n        this.createdAt = time.now()\n\n        const optionsWithDefaults: OptionsWithoutKeyframes<T> = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            name,\n            motionValue,\n            element,\n            ...options,\n        }\n\n        const KeyframeResolver =\n            element?.KeyframeResolver || DefaultKeyframeResolver\n\n        this.keyframeResolver = new KeyframeResolver(\n            keyframes,\n            (\n                resolvedKeyframes: ResolvedKeyframes<T>,\n                finalKeyframe: T,\n                forced: boolean\n            ) =>\n                this.onKeyframesResolved(\n                    resolvedKeyframes,\n                    finalKeyframe,\n                    optionsWithDefaults,\n                    !forced\n                ),\n            name,\n            motionValue,\n            element\n        )\n        this.keyframeResolver?.scheduleResolve()\n    }\n\n    onKeyframesResolved(\n        keyframes: ResolvedKeyframes<T>,\n        finalKeyframe: T,\n        options: OptionsWithoutKeyframes<T>,\n        sync: boolean\n    ) {\n        this.keyframeResolver = undefined\n\n        const { name, type, velocity, delay, isHandoff, onUpdate } = options\n        this.resolvedAt = time.now()\n\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            if (MotionGlobalConfig.instantAnimations || !delay) {\n                onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe))\n            }\n\n            keyframes[0] = keyframes[keyframes.length - 1]\n\n            makeAnimationInstant(options)\n            options.repeat = 0\n        }\n\n        /**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first committed frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */\n        const startTime = sync\n            ? !this.resolvedAt\n                ? this.createdAt\n                : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n                ? this.resolvedAt\n                : this.createdAt\n            : undefined\n\n        const resolvedOptions = {\n            startTime,\n            finalKeyframe,\n            ...options,\n            keyframes,\n        }\n\n        /**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        const useWaapi = !isHandoff && supportsBrowserAnimation(resolvedOptions)\n        const element = resolvedOptions.motionValue?.owner?.current\n\n        const animation = useWaapi\n                ? new NativeAnimationExtended({\n                      ...resolvedOptions,\n                      element,\n                  } as any)\n                : new JSAnimation(resolvedOptions)\n\n        animation.finished.then(() => {\n            this.notifyFinished()\n        }).catch(noop)\n\n        if (this.pendingTimeline) {\n            this.stopTimeline = animation.attachTimeline(this.pendingTimeline)\n            this.pendingTimeline = undefined\n        }\n\n        this._animation = animation\n    }\n\n    get finished() {\n        if (!this._animation) {\n            return this._finished\n        } else {\n            return this.animation.finished\n        }\n    }\n\n    then(onResolve: VoidFunction, _onReject?: VoidFunction) {\n        return this.finished.finally(onResolve).then(() => {})\n    }\n\n    get animation(): AnimationPlaybackControls {\n        if (!this._animation) {\n            this.keyframeResolver?.resume()\n            flushKeyframeResolvers()\n        }\n\n        return this._animation!\n    }\n\n    get duration() {\n        return this.animation.duration\n    }\n\n    get iterationDuration() {\n        return this.animation.iterationDuration\n    }\n\n    get time() {\n        return this.animation.time\n    }\n\n    set time(newTime: number) {\n        this.animation.time = newTime\n    }\n\n    get speed() {\n        return this.animation.speed\n    }\n\n    get state() {\n        return this.animation.state\n    }\n\n    set speed(newSpeed: number) {\n        this.animation.speed = newSpeed\n    }\n\n    get startTime() {\n        return this.animation.startTime\n    }\n\n    attachTimeline(timeline: TimelineWithFallback) {\n        if (this._animation) {\n            this.stopTimeline = this.animation.attachTimeline(timeline)\n        } else {\n            this.pendingTimeline = timeline\n        }\n\n        return () => this.stop()\n    }\n\n    play() {\n        this.animation.play()\n    }\n\n    pause() {\n        this.animation.pause()\n    }\n\n    complete() {\n        this.animation.complete()\n    }\n\n    cancel() {\n        if (this._animation) {\n            this.animation.cancel()\n        }\n\n        this.keyframeResolver?.cancel()\n    }\n\n    /**\n     * Bound to support return animation.stop pattern\n     */\n    stop = () => {\n        if (this._animation) {\n            this._animation.stop()\n            this.stopTimeline?.()\n        }\n\n        this.keyframeResolver?.cancel()\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}