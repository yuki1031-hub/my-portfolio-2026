{"ast":null,"code":"import { isDragActive } from './drag/state/is-active.mjs';\nimport { setupGesture } from './utils/setup.mjs';\nfunction isValidHover(event) {\n  return !(event.pointerType === \"touch\" || isDragActive());\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n  elements.forEach(element => {\n    let isPressed = false;\n    let deferredHoverEnd = false;\n    let hoverEndCallback;\n    const removePointerLeave = () => {\n      element.removeEventListener(\"pointerleave\", onPointerLeave);\n    };\n    const endHover = event => {\n      if (hoverEndCallback) {\n        hoverEndCallback(event);\n        hoverEndCallback = undefined;\n      }\n      removePointerLeave();\n    };\n    const onPointerUp = event => {\n      isPressed = false;\n      window.removeEventListener(\"pointerup\", onPointerUp);\n      window.removeEventListener(\"pointercancel\", onPointerUp);\n      if (deferredHoverEnd) {\n        deferredHoverEnd = false;\n        endHover(event);\n      }\n    };\n    const onPointerDown = () => {\n      isPressed = true;\n      window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n      window.addEventListener(\"pointercancel\", onPointerUp, eventOptions);\n    };\n    const onPointerLeave = leaveEvent => {\n      if (leaveEvent.pointerType === \"touch\") return;\n      if (isPressed) {\n        deferredHoverEnd = true;\n        return;\n      }\n      endHover(leaveEvent);\n    };\n    const onPointerEnter = enterEvent => {\n      if (!isValidHover(enterEvent)) return;\n      deferredHoverEnd = false;\n      const onHoverEnd = onHoverStart(element, enterEvent);\n      if (typeof onHoverEnd !== \"function\") return;\n      hoverEndCallback = onHoverEnd;\n      element.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n    };\n    element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n    element.addEventListener(\"pointerdown\", onPointerDown, eventOptions);\n  });\n  return cancel;\n}\nexport { hover };","map":{"version":3,"names":["isValidHover","event","pointerType","isDragActive","hover","elementOrSelector","onHoverStart","options","arguments","length","undefined","elements","eventOptions","cancel","setupGesture","forEach","element","isPressed","deferredHoverEnd","hoverEndCallback","removePointerLeave","removeEventListener","onPointerLeave","endHover","onPointerUp","window","onPointerDown","addEventListener","leaveEvent","onPointerEnter","enterEvent","onHoverEnd"],"sources":["C:\\Users\\hishi\\Documents\\ポートフォリオ2026\\portfolio\\my-portfolio-2026\\node_modules\\motion-dom\\src\\gestures\\hover.ts"],"sourcesContent":["import { ElementOrSelector } from \"../utils/resolve-elements\"\nimport { isDragActive } from \"./drag/state/is-active\"\nimport { EventOptions } from \"./types\"\nimport { setupGesture } from \"./utils/setup\"\n\n/**\n * A function to be called when a hover gesture starts.\n *\n * This function can optionally return a function that will be called\n * when the hover gesture ends.\n *\n * @public\n */\nexport type OnHoverStartEvent = (\n    element: Element,\n    event: PointerEvent\n) => void | OnHoverEndEvent\n\n/**\n * A function to be called when a hover gesture ends.\n *\n * @public\n */\nexport type OnHoverEndEvent = (event: PointerEvent) => void\n\nfunction isValidHover(event: PointerEvent) {\n    return !(event.pointerType === \"touch\" || isDragActive())\n}\n\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nexport function hover(\n    elementOrSelector: ElementOrSelector,\n    onHoverStart: OnHoverStartEvent,\n    options: EventOptions = {}\n): VoidFunction {\n    const [elements, eventOptions, cancel] = setupGesture(\n        elementOrSelector,\n        options\n    )\n\n    elements.forEach((element) => {\n        let isPressed = false\n        let deferredHoverEnd = false\n        let hoverEndCallback: OnHoverEndEvent | undefined\n\n        const removePointerLeave = () => {\n            element.removeEventListener(\n                \"pointerleave\",\n                onPointerLeave as EventListener\n            )\n        }\n\n        const endHover = (event: PointerEvent) => {\n            if (hoverEndCallback) {\n                hoverEndCallback(event)\n                hoverEndCallback = undefined\n            }\n            removePointerLeave()\n        }\n\n        const onPointerUp = (event: Event) => {\n            isPressed = false\n            window.removeEventListener(\n                \"pointerup\",\n                onPointerUp as EventListener\n            )\n            window.removeEventListener(\n                \"pointercancel\",\n                onPointerUp as EventListener\n            )\n\n            if (deferredHoverEnd) {\n                deferredHoverEnd = false\n                endHover(event as PointerEvent)\n            }\n        }\n\n        const onPointerDown = () => {\n            isPressed = true\n            window.addEventListener(\n                \"pointerup\",\n                onPointerUp as EventListener,\n                eventOptions\n            )\n            window.addEventListener(\n                \"pointercancel\",\n                onPointerUp as EventListener,\n                eventOptions\n            )\n        }\n\n        const onPointerLeave = (leaveEvent: PointerEvent) => {\n            if (leaveEvent.pointerType === \"touch\") return\n\n            if (isPressed) {\n                deferredHoverEnd = true\n                return\n            }\n\n            endHover(leaveEvent)\n        }\n\n        const onPointerEnter = (enterEvent: PointerEvent) => {\n            if (!isValidHover(enterEvent)) return\n\n            deferredHoverEnd = false\n\n            const onHoverEnd = onHoverStart(\n                element as Element,\n                enterEvent\n            )\n\n            if (typeof onHoverEnd !== \"function\") return\n\n            hoverEndCallback = onHoverEnd\n\n            element.addEventListener(\n                \"pointerleave\",\n                onPointerLeave as EventListener,\n                eventOptions\n            )\n        }\n\n        element.addEventListener(\n            \"pointerenter\",\n            onPointerEnter as EventListener,\n            eventOptions\n        )\n        element.addEventListener(\n            \"pointerdown\",\n            onPointerDown as EventListener,\n            eventOptions\n        )\n    })\n\n    return cancel\n}\n"],"mappings":";;AAyBA,SAASA,YAAYA,CAACC,KAAmB;EACrC,OAAO,EAAEA,KAAK,CAACC,WAAW,KAAK,OAAO,IAAIC,YAAY,EAAE,CAAC;AAC7D;AAEA;;;;;;AAMG;AACG,SAAUC,KAAKA,CACjBC,iBAAoC,EACpCC,YAA+B,EACL;EAAA,IAA1BC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAwB,EAAE;EAE1B,MAAM,CAACG,QAAQ,EAAEC,YAAY,EAAEC,MAAM,CAAC,GAAGC,YAAY,CACjDT,iBAAiB,EACjBE,OAAO,CACV;EAEDI,QAAQ,CAACI,OAAO,CAAEC,OAAO,IAAI;IACzB,IAAIC,SAAS,GAAG,KAAK;IACrB,IAAIC,gBAAgB,GAAG,KAAK;IAC5B,IAAIC,gBAA6C;IAEjD,MAAMC,kBAAkB,GAAGA,CAAA,KAAK;MAC5BJ,OAAO,CAACK,mBAAmB,CACvB,cAAc,EACdC,cAA+B,CAClC;IACL,CAAC;IAED,MAAMC,QAAQ,GAAItB,KAAmB,IAAI;MACrC,IAAIkB,gBAAgB,EAAE;QAClBA,gBAAgB,CAAClB,KAAK,CAAC;QACvBkB,gBAAgB,GAAGT,SAAS;;MAEhCU,kBAAkB,EAAE;IACxB,CAAC;IAED,MAAMI,WAAW,GAAIvB,KAAY,IAAI;MACjCgB,SAAS,GAAG,KAAK;MACjBQ,MAAM,CAACJ,mBAAmB,CACtB,WAAW,EACXG,WAA4B,CAC/B;MACDC,MAAM,CAACJ,mBAAmB,CACtB,eAAe,EACfG,WAA4B,CAC/B;MAED,IAAIN,gBAAgB,EAAE;QAClBA,gBAAgB,GAAG,KAAK;QACxBK,QAAQ,CAACtB,KAAqB,CAAC;;IAEvC,CAAC;IAED,MAAMyB,aAAa,GAAGA,CAAA,KAAK;MACvBT,SAAS,GAAG,IAAI;MAChBQ,MAAM,CAACE,gBAAgB,CACnB,WAAW,EACXH,WAA4B,EAC5BZ,YAAY,CACf;MACDa,MAAM,CAACE,gBAAgB,CACnB,eAAe,EACfH,WAA4B,EAC5BZ,YAAY,CACf;IACL,CAAC;IAED,MAAMU,cAAc,GAAIM,UAAwB,IAAI;MAChD,IAAIA,UAAU,CAAC1B,WAAW,KAAK,OAAO,EAAE;MAExC,IAAIe,SAAS,EAAE;QACXC,gBAAgB,GAAG,IAAI;QACvB;;MAGJK,QAAQ,CAACK,UAAU,CAAC;IACxB,CAAC;IAED,MAAMC,cAAc,GAAIC,UAAwB,IAAI;MAChD,IAAI,CAAC9B,YAAY,CAAC8B,UAAU,CAAC,EAAE;MAE/BZ,gBAAgB,GAAG,KAAK;MAExB,MAAMa,UAAU,GAAGzB,YAAY,CAC3BU,OAAkB,EAClBc,UAAU,CACb;MAED,IAAI,OAAOC,UAAU,KAAK,UAAU,EAAE;MAEtCZ,gBAAgB,GAAGY,UAAU;MAE7Bf,OAAO,CAACW,gBAAgB,CACpB,cAAc,EACdL,cAA+B,EAC/BV,YAAY,CACf;IACL,CAAC;IAEDI,OAAO,CAACW,gBAAgB,CACpB,cAAc,EACdE,cAA+B,EAC/BjB,YAAY,CACf;IACDI,OAAO,CAACW,gBAAgB,CACpB,aAAa,EACbD,aAA8B,EAC9Bd,YAAY,CACf;EACL,CAAC,CAAC;EAEF,OAAOC,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}