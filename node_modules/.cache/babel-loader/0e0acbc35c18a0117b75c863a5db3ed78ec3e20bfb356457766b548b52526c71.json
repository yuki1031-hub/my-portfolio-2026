{"ast":null,"code":"import _objectSpread from \"C:/Users/hishi/Documents/\\u30DD\\u30FC\\u30C8\\u30D5\\u30A9\\u30EA\\u30AA2026/portfolio/my-portfolio-2026/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { GroupAnimation } from '../animation/GroupAnimation.mjs';\nimport { copyBoxInto } from '../projection/geometry/copy.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { HTMLProjectionNode } from '../projection/node/HTMLProjectionNode.mjs';\nimport { HTMLVisualElement } from '../render/html/HTMLVisualElement.mjs';\nimport { visualElementStore } from '../render/store.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\nimport { frame } from '../frameloop/frame.mjs';\nconst layoutSelector = \"[data-layout], [data-layout-id]\";\nconst noop = () => {};\nfunction snapshotFromTarget(projection) {\n  var _projection$root$anim, _projection$root;\n  const target = projection.targetWithTransforms || projection.target;\n  if (!target) return undefined;\n  const measuredBox = createBox();\n  const layoutBox = createBox();\n  copyBoxInto(measuredBox, target);\n  copyBoxInto(layoutBox, target);\n  return {\n    animationId: (_projection$root$anim = (_projection$root = projection.root) === null || _projection$root === void 0 ? void 0 : _projection$root.animationId) !== null && _projection$root$anim !== void 0 ? _projection$root$anim : 0,\n    measuredBox,\n    layoutBox,\n    latestValues: projection.animationValues || projection.latestValues || {},\n    source: projection.id\n  };\n}\nclass LayoutAnimationBuilder {\n  constructor(scope, updateDom, defaultOptions) {\n    this.sharedTransitions = new Map();\n    this.notifyReady = noop;\n    this.rejectReady = noop;\n    this.scope = scope;\n    this.updateDom = updateDom;\n    this.defaultOptions = defaultOptions;\n    this.readyPromise = new Promise((resolve, reject) => {\n      this.notifyReady = resolve;\n      this.rejectReady = reject;\n    });\n    frame.postRender(() => {\n      this.start().then(this.notifyReady).catch(this.rejectReady);\n    });\n  }\n  shared(id, transition) {\n    this.sharedTransitions.set(id, transition);\n    return this;\n  }\n  then(resolve, reject) {\n    return this.readyPromise.then(resolve, reject);\n  }\n  async start() {\n    const beforeElements = collectLayoutElements(this.scope);\n    const beforeRecords = this.buildRecords(beforeElements);\n    beforeRecords.forEach(_ref => {\n      let {\n        projection\n      } = _ref;\n      const hasCurrentAnimation = Boolean(projection.currentAnimation);\n      const isSharedLayout = Boolean(projection.options.layoutId);\n      if (hasCurrentAnimation && isSharedLayout) {\n        const snapshot = snapshotFromTarget(projection);\n        if (snapshot) {\n          projection.snapshot = snapshot;\n        } else if (projection.snapshot) {\n          projection.snapshot = undefined;\n        }\n      } else if (projection.snapshot && (projection.currentAnimation || projection.isProjecting())) {\n        projection.snapshot = undefined;\n      }\n      projection.isPresent = true;\n      projection.willUpdate();\n    });\n    await this.updateDom();\n    const afterElements = collectLayoutElements(this.scope);\n    const afterRecords = this.buildRecords(afterElements);\n    this.handleExitingElements(beforeRecords, afterRecords);\n    afterRecords.forEach(_ref2 => {\n      var _projection$resumeFro;\n      let {\n        projection\n      } = _ref2;\n      const instance = projection.instance;\n      const resumeFromInstance = (_projection$resumeFro = projection.resumeFrom) === null || _projection$resumeFro === void 0 ? void 0 : _projection$resumeFro.instance;\n      if (!instance || !resumeFromInstance) return;\n      if (!(\"style\" in instance)) return;\n      const currentTransform = instance.style.transform;\n      const resumeFromTransform = resumeFromInstance.style.transform;\n      if (currentTransform && resumeFromTransform && currentTransform === resumeFromTransform) {\n        instance.style.transform = \"\";\n        instance.style.transformOrigin = \"\";\n      }\n    });\n    afterRecords.forEach(_ref3 => {\n      let {\n        projection\n      } = _ref3;\n      projection.isPresent = true;\n    });\n    const root = getProjectionRoot(afterRecords, beforeRecords);\n    root === null || root === void 0 || root.didUpdate();\n    await new Promise(resolve => {\n      frame.postRender(() => resolve());\n    });\n    const animations = collectAnimations(afterRecords);\n    const animation = new GroupAnimation(animations);\n    return animation;\n  }\n  buildRecords(elements) {\n    const records = [];\n    const recordMap = new Map();\n    for (const element of elements) {\n      const parentRecord = findParentRecord(element, recordMap, this.scope);\n      const {\n        layout,\n        layoutId\n      } = readLayoutAttributes(element);\n      const override = layoutId ? this.sharedTransitions.get(layoutId) : undefined;\n      const transition = override || this.defaultOptions;\n      const record = getOrCreateRecord(element, parentRecord === null || parentRecord === void 0 ? void 0 : parentRecord.projection, {\n        layout,\n        layoutId,\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        transition: transition\n      });\n      recordMap.set(element, record);\n      records.push(record);\n    }\n    return records;\n  }\n  handleExitingElements(beforeRecords, afterRecords) {\n    const afterElementsSet = new Set(afterRecords.map(record => record.element));\n    beforeRecords.forEach(record => {\n      if (afterElementsSet.has(record.element)) return;\n      // For shared layout elements, relegate to set up resumeFrom\n      // so the remaining element animates from this position\n      if (record.projection.options.layoutId) {\n        record.projection.isPresent = false;\n        record.projection.relegate();\n      }\n      record.visualElement.unmount();\n      visualElementStore.delete(record.element);\n    });\n    // Clear resumeFrom on EXISTING nodes that point to unmounted projections\n    // This prevents crossfade animation when the source element was removed entirely\n    // But preserve resumeFrom for NEW nodes so they can animate from the old position\n    // Also preserve resumeFrom for lead nodes that were just promoted via relegate\n    const beforeElementsSet = new Set(beforeRecords.map(record => record.element));\n    afterRecords.forEach(_ref4 => {\n      let {\n        element,\n        projection\n      } = _ref4;\n      if (beforeElementsSet.has(element) && projection.resumeFrom && !projection.resumeFrom.instance && !projection.isLead()) {\n        projection.resumeFrom = undefined;\n        projection.snapshot = undefined;\n      }\n    });\n  }\n}\nfunction parseAnimateLayoutArgs(scopeOrUpdateDom, updateDomOrOptions, options) {\n  // animateLayout(updateDom)\n  if (typeof scopeOrUpdateDom === \"function\") {\n    return {\n      scope: document,\n      updateDom: scopeOrUpdateDom,\n      defaultOptions: updateDomOrOptions\n    };\n  }\n  // animateLayout(scope, updateDom, options?)\n  const elements = resolveElements(scopeOrUpdateDom);\n  const scope = elements[0] || document;\n  return {\n    scope,\n    updateDom: updateDomOrOptions,\n    defaultOptions: options\n  };\n}\nfunction collectLayoutElements(scope) {\n  const elements = Array.from(scope.querySelectorAll(layoutSelector));\n  if (scope instanceof Element && scope.matches(layoutSelector)) {\n    if (!elements.includes(scope)) {\n      elements.unshift(scope);\n    }\n  }\n  return elements;\n}\nfunction readLayoutAttributes(element) {\n  const layoutId = element.getAttribute(\"data-layout-id\") || undefined;\n  const rawLayout = element.getAttribute(\"data-layout\");\n  let layout;\n  if (rawLayout === \"\" || rawLayout === \"true\") {\n    layout = true;\n  } else if (rawLayout) {\n    layout = rawLayout;\n  }\n  return {\n    layout,\n    layoutId\n  };\n}\nfunction createVisualState() {\n  return {\n    latestValues: {},\n    renderState: {\n      transform: {},\n      transformOrigin: {},\n      style: {},\n      vars: {}\n    }\n  };\n}\nfunction getOrCreateRecord(element, parentProjection, projectionOptions) {\n  const existing = visualElementStore.get(element);\n  const visualElement = existing !== null && existing !== void 0 ? existing : new HTMLVisualElement({\n    props: {},\n    presenceContext: null,\n    visualState: createVisualState()\n  }, {\n    allowProjection: true\n  });\n  if (!existing || !visualElement.projection) {\n    visualElement.projection = new HTMLProjectionNode(visualElement.latestValues, parentProjection);\n  }\n  visualElement.projection.setOptions(_objectSpread(_objectSpread({}, projectionOptions), {}, {\n    visualElement\n  }));\n  if (!visualElement.current) {\n    visualElement.mount(element);\n  } else if (!visualElement.projection.instance) {\n    // Mount projection if VisualElement is already mounted but projection isn't\n    // This happens when animate() was called before animateLayout()\n    visualElement.projection.mount(element);\n  }\n  if (!existing) {\n    visualElementStore.set(element, visualElement);\n  }\n  return {\n    element,\n    visualElement,\n    projection: visualElement.projection\n  };\n}\nfunction findParentRecord(element, recordMap, scope) {\n  let parent = element.parentElement;\n  while (parent) {\n    const record = recordMap.get(parent);\n    if (record) return record;\n    if (parent === scope) break;\n    parent = parent.parentElement;\n  }\n  return undefined;\n}\nfunction getProjectionRoot(afterRecords, beforeRecords) {\n  const record = afterRecords[0] || beforeRecords[0];\n  return record === null || record === void 0 ? void 0 : record.projection.root;\n}\nfunction collectAnimations(afterRecords) {\n  const animations = new Set();\n  afterRecords.forEach(record => {\n    const animation = record.projection.currentAnimation;\n    if (animation) animations.add(animation);\n  });\n  return Array.from(animations);\n}\nexport { LayoutAnimationBuilder, parseAnimateLayoutArgs };","map":{"version":3,"names":["layoutSelector","noop","snapshotFromTarget","projection","_projection$root$anim","_projection$root","target","targetWithTransforms","undefined","measuredBox","createBox","layoutBox","copyBoxInto","animationId","root","latestValues","animationValues","source","id","LayoutAnimationBuilder","constructor","scope","updateDom","defaultOptions","sharedTransitions","Map","notifyReady","rejectReady","readyPromise","Promise","resolve","reject","frame","postRender","start","then","catch","shared","transition","set","beforeElements","collectLayoutElements","beforeRecords","buildRecords","forEach","_ref","hasCurrentAnimation","Boolean","currentAnimation","isSharedLayout","options","layoutId","snapshot","isProjecting","isPresent","willUpdate","afterElements","afterRecords","handleExitingElements","_ref2","_projection$resumeFro","instance","resumeFromInstance","resumeFrom","currentTransform","style","transform","resumeFromTransform","transformOrigin","_ref3","getProjectionRoot","didUpdate","animations","collectAnimations","animation","GroupAnimation","elements","records","recordMap","element","parentRecord","findParentRecord","layout","readLayoutAttributes","override","get","record","getOrCreateRecord","animationType","push","afterElementsSet","Set","map","has","relegate","visualElement","unmount","visualElementStore","delete","beforeElementsSet","_ref4","isLead","parseAnimateLayoutArgs","scopeOrUpdateDom","updateDomOrOptions","document","resolveElements","Array","from","querySelectorAll","Element","matches","includes","unshift","getAttribute","rawLayout","createVisualState","renderState","vars","parentProjection","projectionOptions","existing","HTMLVisualElement","props","presenceContext","visualState","allowProjection","HTMLProjectionNode","setOptions","_objectSpread","current","mount","parent","parentElement","add"],"sources":["C:\\Users\\hishi\\Documents\\ポートフォリオ2026\\portfolio\\my-portfolio-2026\\node_modules\\motion-dom\\src\\layout\\LayoutAnimationBuilder.ts"],"sourcesContent":["import type { Box } from \"motion-utils\"\nimport { GroupAnimation } from \"../animation/GroupAnimation\"\nimport type {\n    AnimationOptions,\n    AnimationPlaybackControls,\n    Transition,\n} from \"../animation/types\"\nimport { frame } from \"../frameloop\"\nimport { copyBoxInto } from \"../projection/geometry/copy\"\nimport { createBox } from \"../projection/geometry/models\"\nimport { HTMLProjectionNode } from \"../projection/node/HTMLProjectionNode\"\nimport type { IProjectionNode } from \"../projection/node/types\"\nimport { HTMLVisualElement } from \"../render/html/HTMLVisualElement\"\nimport { visualElementStore } from \"../render/store\"\nimport type { VisualElement } from \"../render/VisualElement\"\nimport { resolveElements, type ElementOrSelector } from \"../utils/resolve-elements\"\n\ntype LayoutAnimationScope = Element | Document\n\ninterface LayoutElementRecord {\n    element: Element\n    visualElement: VisualElement\n    projection: IProjectionNode\n}\n\ninterface LayoutAttributes {\n    layout?: boolean | \"position\" | \"size\" | \"preserve-aspect\"\n    layoutId?: string\n}\n\ntype LayoutBuilderResolve = (animation: GroupAnimation) => void\ntype LayoutBuilderReject = (error: unknown) => void\n\ninterface ProjectionOptions {\n    layout?: boolean | \"position\" | \"size\" | \"preserve-aspect\"\n    layoutId?: string\n    animationType?: \"size\" | \"position\" | \"both\" | \"preserve-aspect\"\n    transition?: Transition\n    crossfade?: boolean\n}\n\nconst layoutSelector = \"[data-layout], [data-layout-id]\"\nconst noop = () => {}\nfunction snapshotFromTarget(projection: IProjectionNode): LayoutElementRecord[\"projection\"][\"snapshot\"] {\n    const target = projection.targetWithTransforms || projection.target\n    if (!target) return undefined\n\n    const measuredBox = createBox()\n    const layoutBox = createBox()\n    copyBoxInto(measuredBox, target as Box)\n    copyBoxInto(layoutBox, target as Box)\n\n    return {\n        animationId: projection.root?.animationId ?? 0,\n        measuredBox,\n        layoutBox,\n        latestValues: projection.animationValues || projection.latestValues || {},\n        source: projection.id,\n    }\n}\n\nexport class LayoutAnimationBuilder {\n    private scope: LayoutAnimationScope\n    private updateDom: () => void | Promise<void>\n    private defaultOptions?: AnimationOptions\n    private sharedTransitions = new Map<string, AnimationOptions>()\n    private notifyReady: LayoutBuilderResolve = noop\n    private rejectReady: LayoutBuilderReject = noop\n    private readyPromise: Promise<GroupAnimation>\n\n    constructor(\n        scope: LayoutAnimationScope,\n        updateDom: () => void | Promise<void>,\n        defaultOptions?: AnimationOptions\n    ) {\n        this.scope = scope\n        this.updateDom = updateDom\n        this.defaultOptions = defaultOptions\n\n        this.readyPromise = new Promise<GroupAnimation>((resolve, reject) => {\n            this.notifyReady = resolve\n            this.rejectReady = reject\n        })\n\n        frame.postRender(() => {\n            this.start().then(this.notifyReady).catch(this.rejectReady)\n        })\n    }\n\n    shared(id: string, transition: AnimationOptions): this {\n        this.sharedTransitions.set(id, transition)\n        return this\n    }\n\n    then(\n        resolve: LayoutBuilderResolve,\n        reject?: LayoutBuilderReject\n    ): Promise<void> {\n        return this.readyPromise.then(resolve, reject)\n    }\n\n    private async start(): Promise<GroupAnimation> {\n        const beforeElements = collectLayoutElements(this.scope)\n        const beforeRecords = this.buildRecords(beforeElements)\n\n        beforeRecords.forEach(({ projection }) => {\n            const hasCurrentAnimation = Boolean(projection.currentAnimation)\n            const isSharedLayout = Boolean(projection.options.layoutId)\n            if (hasCurrentAnimation && isSharedLayout) {\n                const snapshot = snapshotFromTarget(projection)\n                if (snapshot) {\n                    projection.snapshot = snapshot\n                } else if (projection.snapshot) {\n                    projection.snapshot = undefined\n                }\n            } else if (\n                projection.snapshot &&\n                (projection.currentAnimation || projection.isProjecting())\n            ) {\n                projection.snapshot = undefined\n            }\n            projection.isPresent = true\n            projection.willUpdate()\n        })\n\n        await this.updateDom()\n\n        const afterElements = collectLayoutElements(this.scope)\n        const afterRecords = this.buildRecords(afterElements)\n        this.handleExitingElements(beforeRecords, afterRecords)\n\n        afterRecords.forEach(({ projection }) => {\n            const instance = projection.instance as HTMLElement | undefined\n            const resumeFromInstance = projection.resumeFrom\n                ?.instance as HTMLElement | undefined\n            if (!instance || !resumeFromInstance) return\n            if (!(\"style\" in instance)) return\n\n            const currentTransform = instance.style.transform\n            const resumeFromTransform = resumeFromInstance.style.transform\n\n            if (\n                currentTransform &&\n                resumeFromTransform &&\n                currentTransform === resumeFromTransform\n            ) {\n                instance.style.transform = \"\"\n                instance.style.transformOrigin = \"\"\n            }\n        })\n\n        afterRecords.forEach(({ projection }) => {\n            projection.isPresent = true\n        })\n\n        const root = getProjectionRoot(afterRecords, beforeRecords)\n        root?.didUpdate()\n\n        await new Promise<void>((resolve) => {\n            frame.postRender(() => resolve())\n        })\n\n        const animations = collectAnimations(afterRecords)\n        const animation = new GroupAnimation(animations)\n\n        return animation\n    }\n\n    private buildRecords(elements: Element[]): LayoutElementRecord[] {\n        const records: LayoutElementRecord[] = []\n        const recordMap = new Map<Element, LayoutElementRecord>()\n\n        for (const element of elements) {\n            const parentRecord = findParentRecord(element, recordMap, this.scope)\n            const { layout, layoutId } = readLayoutAttributes(element)\n            const override = layoutId\n                ? this.sharedTransitions.get(layoutId)\n                : undefined\n            const transition = override || this.defaultOptions\n            const record = getOrCreateRecord(element, parentRecord?.projection, {\n                layout,\n                layoutId,\n                animationType: typeof layout === \"string\" ? layout : \"both\",\n                transition: transition as Transition,\n            })\n            recordMap.set(element, record)\n            records.push(record)\n        }\n\n        return records\n    }\n\n    private handleExitingElements(\n        beforeRecords: LayoutElementRecord[],\n        afterRecords: LayoutElementRecord[]\n    ): void {\n        const afterElementsSet = new Set(afterRecords.map((record) => record.element))\n\n        beforeRecords.forEach((record) => {\n            if (afterElementsSet.has(record.element)) return\n\n            // For shared layout elements, relegate to set up resumeFrom\n            // so the remaining element animates from this position\n            if (record.projection.options.layoutId) {\n                record.projection.isPresent = false\n                record.projection.relegate()\n            }\n\n            record.visualElement.unmount()\n            visualElementStore.delete(record.element)\n        })\n\n        // Clear resumeFrom on EXISTING nodes that point to unmounted projections\n        // This prevents crossfade animation when the source element was removed entirely\n        // But preserve resumeFrom for NEW nodes so they can animate from the old position\n        // Also preserve resumeFrom for lead nodes that were just promoted via relegate\n        const beforeElementsSet = new Set(beforeRecords.map((record) => record.element))\n        afterRecords.forEach(({ element, projection }) => {\n            if (\n                beforeElementsSet.has(element) &&\n                projection.resumeFrom &&\n                !projection.resumeFrom.instance &&\n                !projection.isLead()\n            ) {\n                projection.resumeFrom = undefined\n                projection.snapshot = undefined\n            }\n        })\n    }\n}\n\nexport function parseAnimateLayoutArgs(\n    scopeOrUpdateDom: ElementOrSelector | (() => void),\n    updateDomOrOptions?: (() => void) | AnimationOptions,\n    options?: AnimationOptions\n): {\n    scope: Element | Document\n    updateDom: () => void\n    defaultOptions?: AnimationOptions\n} {\n    // animateLayout(updateDom)\n    if (typeof scopeOrUpdateDom === \"function\") {\n        return {\n            scope: document,\n            updateDom: scopeOrUpdateDom,\n            defaultOptions: updateDomOrOptions as AnimationOptions | undefined,\n        }\n    }\n\n    // animateLayout(scope, updateDom, options?)\n    const elements = resolveElements(scopeOrUpdateDom)\n    const scope = elements[0] || document\n\n    return {\n        scope,\n        updateDom: updateDomOrOptions as () => void,\n        defaultOptions: options,\n    }\n}\n\nfunction collectLayoutElements(scope: LayoutAnimationScope): Element[] {\n    const elements = Array.from(scope.querySelectorAll(layoutSelector))\n\n    if (scope instanceof Element && scope.matches(layoutSelector)) {\n        if (!elements.includes(scope)) {\n            elements.unshift(scope)\n        }\n    }\n\n    return elements\n}\n\nfunction readLayoutAttributes(element: Element): LayoutAttributes {\n    const layoutId = element.getAttribute(\"data-layout-id\") || undefined\n    const rawLayout = element.getAttribute(\"data-layout\")\n    let layout: LayoutAttributes[\"layout\"]\n\n    if (rawLayout === \"\" || rawLayout === \"true\") {\n        layout = true\n    } else if (rawLayout) {\n        layout = rawLayout as LayoutAttributes[\"layout\"]\n    }\n\n    return {\n        layout,\n        layoutId,\n    }\n}\n\nfunction createVisualState() {\n    return {\n        latestValues: {},\n        renderState: {\n            transform: {},\n            transformOrigin: {},\n            style: {},\n            vars: {},\n        },\n    }\n}\n\nfunction getOrCreateRecord(\n    element: Element,\n    parentProjection?: IProjectionNode,\n    projectionOptions?: ProjectionOptions\n): LayoutElementRecord {\n    const existing = visualElementStore.get(element) as VisualElement | undefined\n    const visualElement =\n        existing ??\n        new HTMLVisualElement(\n            {\n                props: {},\n                presenceContext: null,\n                visualState: createVisualState(),\n            },\n            { allowProjection: true }\n        )\n\n    if (!existing || !visualElement.projection) {\n        visualElement.projection = new HTMLProjectionNode(\n            visualElement.latestValues,\n            parentProjection\n        )\n    }\n\n    visualElement.projection.setOptions({\n        ...projectionOptions,\n        visualElement,\n    })\n\n    if (!visualElement.current) {\n        visualElement.mount(element as HTMLElement)\n    } else if (!visualElement.projection.instance) {\n        // Mount projection if VisualElement is already mounted but projection isn't\n        // This happens when animate() was called before animateLayout()\n        visualElement.projection.mount(element as HTMLElement)\n    }\n\n    if (!existing) {\n        visualElementStore.set(element, visualElement)\n    }\n\n    return {\n        element,\n        visualElement,\n        projection: visualElement.projection as IProjectionNode,\n    }\n}\n\nfunction findParentRecord(\n    element: Element,\n    recordMap: Map<Element, LayoutElementRecord>,\n    scope: LayoutAnimationScope\n) {\n    let parent = element.parentElement\n\n    while (parent) {\n        const record = recordMap.get(parent)\n        if (record) return record\n\n        if (parent === scope) break\n        parent = parent.parentElement\n    }\n\n    return undefined\n}\n\nfunction getProjectionRoot(\n    afterRecords: LayoutElementRecord[],\n    beforeRecords: LayoutElementRecord[]\n) {\n    const record = afterRecords[0] || beforeRecords[0]\n    return record?.projection.root\n}\n\nfunction collectAnimations(afterRecords: LayoutElementRecord[]) {\n    const animations = new Set<AnimationPlaybackControls>()\n\n    afterRecords.forEach((record) => {\n        const animation = record.projection.currentAnimation\n        if (animation) animations.add(animation)\n    })\n\n    return Array.from(animations)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}