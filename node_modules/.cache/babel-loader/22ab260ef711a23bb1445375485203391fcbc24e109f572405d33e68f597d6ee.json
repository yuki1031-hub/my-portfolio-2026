{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport { isHTMLElement } from 'motion-dom';\nimport * as React from 'react';\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { useComposedRefs } from '../../utils/use-composed-ref.mjs';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n  getSnapshotBeforeUpdate(prevProps) {\n    const element = this.props.childRef.current;\n    if (element && prevProps.isPresent && !this.props.isPresent && this.props.pop !== false) {\n      const parent = element.offsetParent;\n      const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;\n      const parentHeight = isHTMLElement(parent) ? parent.offsetHeight || 0 : 0;\n      const size = this.props.sizeRef.current;\n      size.height = element.offsetHeight || 0;\n      size.width = element.offsetWidth || 0;\n      size.top = element.offsetTop;\n      size.left = element.offsetLeft;\n      size.right = parentWidth - size.width - size.left;\n      size.bottom = parentHeight - size.height - size.top;\n    }\n    return null;\n  }\n  /**\n   * Required with getSnapshotBeforeUpdate to stop React complaining.\n   */\n  componentDidUpdate() {}\n  render() {\n    return this.props.children;\n  }\n}\nfunction PopChild(_ref) {\n  var _children$props$ref, _children$props;\n  let {\n    children,\n    isPresent,\n    anchorX,\n    anchorY,\n    root,\n    pop\n  } = _ref;\n  const id = useId();\n  const ref = useRef(null);\n  const size = useRef({\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  });\n  const {\n    nonce\n  } = useContext(MotionConfigContext);\n  /**\n   * In React 19, refs are passed via props.ref instead of element.ref.\n   * We check props.ref first (React 19) and fall back to element.ref (React 18).\n   */\n  const childRef = (_children$props$ref = (_children$props = children.props) === null || _children$props === void 0 ? void 0 : _children$props.ref) !== null && _children$props$ref !== void 0 ? _children$props$ref : children === null || children === void 0 ? void 0 : children.ref;\n  const composedRef = useComposedRefs(ref, childRef);\n  /**\n   * We create and inject a style block so we can apply this explicit\n   * sizing in a non-destructive manner by just deleting the style block.\n   *\n   * We can't apply size via render as the measurement happens\n   * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n   * styles directly on the DOM node, we might be overwriting\n   * styles set via the style prop.\n   */\n  useInsertionEffect(() => {\n    const {\n      width,\n      height,\n      top,\n      left,\n      right,\n      bottom\n    } = size.current;\n    if (isPresent || pop === false || !ref.current || !width || !height) return;\n    const x = anchorX === \"left\" ? \"left: \".concat(left) : \"right: \".concat(right);\n    const y = anchorY === \"bottom\" ? \"bottom: \".concat(bottom) : \"top: \".concat(top);\n    ref.current.dataset.motionPopId = id;\n    const style = document.createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    const parent = root !== null && root !== void 0 ? root : document.head;\n    parent.appendChild(style);\n    if (style.sheet) {\n      style.sheet.insertRule(\"\\n          [data-motion-pop-id=\\\"\".concat(id, \"\\\"] {\\n            position: absolute !important;\\n            width: \").concat(width, \"px !important;\\n            height: \").concat(height, \"px !important;\\n            \").concat(x, \"px !important;\\n            \").concat(y, \"px !important;\\n          }\\n        \"));\n    }\n    return () => {\n      if (parent.contains(style)) {\n        parent.removeChild(style);\n      }\n    };\n  }, [isPresent]);\n  return jsx(PopChildMeasure, {\n    isPresent: isPresent,\n    childRef: ref,\n    sizeRef: size,\n    pop: pop,\n    children: pop === false ? children : React.cloneElement(children, {\n      ref: composedRef\n    })\n  });\n}\nexport { PopChild };","map":{"version":3,"names":["PopChildMeasure","React","Component","getSnapshotBeforeUpdate","prevProps","parent","element","offsetParent","parentWidth","isHTMLElement","offsetWidth","parentHeight","offsetHeight","size","top","offsetTop","left","offsetLeft","right","width","bottom","height","componentDidUpdate","props","children","PopChild","_ref","_children$props$ref","_children$props","isPresent","anchorX","anchorY","root","pop","id","useId","ref","useRef","childRef","current","x","concat","y","nonce","style","document","head","appendChild","sheet","insertRule","contains","removeChild","cloneElement","composedRef"],"sources":["C:\\Users\\hishi\\Documents\\ポートフォリオ2026\\portfolio\\my-portfolio-2026\\node_modules\\framer-motion\\src\\components\\AnimatePresence\\PopChild.tsx"],"sourcesContent":["\"use client\"\n\nimport { isHTMLElement } from \"motion-dom\"\nimport * as React from \"react\"\nimport { useContext, useId, useInsertionEffect, useRef } from \"react\"\n\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { useComposedRefs } from \"../../utils/use-composed-ref\"\n\ninterface Size {\n    width: number\n    height: number\n    top: number\n    left: number\n    right: number\n    bottom: number\n}\n\ninterface Props {\n    children: React.ReactElement\n    isPresent: boolean\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n    pop?: boolean\n}\n\ninterface MeasureProps extends Props {\n    childRef: React.RefObject<HTMLElement | null>\n    sizeRef: React.RefObject<Size>\n}\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component<MeasureProps> {\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const element = this.props.childRef.current\n        if (element && prevProps.isPresent && !this.props.isPresent && this.props.pop !== false) {\n            const parent = element.offsetParent\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0\n            const parentHeight = isHTMLElement(parent)\n                ? parent.offsetHeight || 0\n                : 0\n\n            const size = this.props.sizeRef.current!\n            size.height = element.offsetHeight || 0\n            size.width = element.offsetWidth || 0\n            size.top = element.offsetTop\n            size.left = element.offsetLeft\n            size.right = parentWidth - size.width - size.left\n            size.bottom = parentHeight - size.height - size.top\n        }\n\n        return null\n    }\n\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() {}\n\n    render() {\n        return this.props.children\n    }\n}\n\nexport function PopChild({ children, isPresent, anchorX, anchorY, root, pop }: Props) {\n    const id = useId()\n    const ref = useRef<HTMLElement>(null)\n    const size = useRef<Size>({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n    })\n    const { nonce } = useContext(MotionConfigContext)\n    /**\n     * In React 19, refs are passed via props.ref instead of element.ref.\n     * We check props.ref first (React 19) and fall back to element.ref (React 18).\n     */\n    const childRef =\n        (children.props as { ref?: React.Ref<HTMLElement> })?.ref ??\n        (children as unknown as { ref?: React.Ref<HTMLElement> })?.ref\n    const composedRef = useComposedRefs(ref, childRef)\n\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right, bottom } = size.current\n        if (isPresent || pop === false || !ref.current || !width || !height) return\n\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`\n        const y = anchorY === \"bottom\" ? `bottom: ${bottom}` : `top: ${top}`\n\n        ref.current.dataset.motionPopId = id\n\n        const style = document.createElement(\"style\")\n        if (nonce) style.nonce = nonce\n\n        const parent = root ?? document.head\n        parent.appendChild(style)\n\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            ${y}px !important;\n          }\n        `)\n        }\n\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style)\n            }\n        }\n    }, [isPresent])\n\n    return (\n        <PopChildMeasure isPresent={isPresent} childRef={ref} sizeRef={size} pop={pop}>\n            {pop === false\n                ? children\n                : React.cloneElement(children as any, { ref: composedRef })}\n        </PopChildMeasure>\n    )\n}\n"],"mappings":";;;;;;;;;AAgCA;;;AAGG;AACH,MAAAA,eAAA,SAAAC,KAAA,CAAAC,SAAA;EACIC,wBAAAC,SAAA;;;MAGQ,MAAAC,MAAA,GAAAC,OAAA,CAAAC,YAAA;MACA,MAAAC,WAAA,GAAAC,aAAA,CAAAJ,MAAA,IACIA,MAAA,CAAAK,WAAA,Q;MAEJ,MAAAC,YAAA,GAAAF,aAAA,CAAAJ,MAAA,IACIA,MAAA,CAAAO,YAAA,Q;;;;MAMJC,IAAA,CAAAC,GAAA,GAAAR,OAAA,CAAAS,SAAA;MACAF,IAAA,CAAAG,IAAA,GAAAV,OAAA,CAAAW,UAAA;MACAJ,IAAA,CAAAK,KAAA,GAAAV,WAAA,GAAAK,IAAA,CAAAM,KAAA,GAAAN,IAAA,CAAAG,IAAA;MACAH,IAAA,CAAAO,MAAA,GAAAT,YAAA,GAAAE,IAAA,CAAAQ,MAAA,GAAAR,IAAA,CAAAC,GAAA;;IAGJ;;EAGJ;;AAEG;EACHQ,mBAAA;;IAGI,YAAAC,KAAA,CAAAC,QAAA;;AAEP;AAEe,SAAAC,SAAAC,IAAA;EAAA,IAAAC,mBAAA,EAAAC,eAAA;EAAA;IAAAJ,QAAA;IAAAK,SAAA;IAAAC,OAAA;IAAAC,OAAA;IAAAC,IAAA;IAAAC;EAAA,IAAAP,IAAA;EACZ,MAAAQ,EAAA,GAAAC,KAAA;EACA,MAAAC,GAAA,GAAAC,MAAA;;IAEIlB,KAAA;IACAE,MAAA;IACAP,GAAA;IACAE,IAAA;IACAE,KAAA;IACAE,MAAA;EACH;;;;EAED;;;AAGG;EACH,MAAAkB,QAAA,IAAAX,mBAAA,IAAAC,eAAA,GAAAJ,QAAA,CAAAD,KAAA,cAAAK,eAAA,uBAAAA,eAAA,CAAAQ,GAAA,cAAAT,mBAAA,cAAAA,mBAAA,G;;EAKA;;;;;;;;AAQG;;IAEC;MAAAR,KAAA;MAAAE,MAAA;MAAAP,GAAA;MAAAE,IAAA;MAAAE,KAAA;MAAAE;IAAA,IAAAP,IAAA,CAAA0B,OAAA;IACA,IAAAV,SAAA,IAAAI,GAAA,eAAAG,GAAA,CAAAG,OAAA,KAAApB,KAAA,KAAAE,MAAA,E;IAEA,MAAAmB,CAAA,GAAAV,OAAA,uBAAAW,MAAA,CAAAzB,IAAA,cAAAyB,MAAA,CAAAvB,KAAA;IACA,MAAAwB,CAAA,GAAAX,OAAA,2BAAAU,MAAA,CAAArB,MAAA,YAAAqB,MAAA,CAAA3B,GAAA;;;IAKA,IAAA6B,KAAA,EAAWC,KAAA,CAAAD,KAAA,GAAAA,KAAA;IAEX,MAAAtC,MAAA,GAAA2B,IAAA,aAAAA,IAAA,cAAAA,IAAA,GAAAa,QAAA,CAAAC,IAAA;IACAzC,MAAA,CAAA0C,WAAA,CAAAH,KAAA;IAEA,IAAAA,KAAA,CAAAI,KAAA;MACIJ,KAAA,CAAAI,KAAA,CAAAC,UAAA,sCAAAR,MAAA,C,+QAQH;;IAGD;MACI,IAAApC,MAAA,CAAA6C,QAAA,CAAAN,KAAA;QACIvC,MAAA,CAAA8C,WAAA,CAAAP,KAAA;;IAER;EACJ,IAAAf,SAAA;;;;;;8BAKYL,QAAA,GACAvB,KAAA,CAAAmD,YAAA,CAAA5B,QAAA;MAAAY,GAAA,EAAAiB;IAAA;EAAA;AAGhB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}