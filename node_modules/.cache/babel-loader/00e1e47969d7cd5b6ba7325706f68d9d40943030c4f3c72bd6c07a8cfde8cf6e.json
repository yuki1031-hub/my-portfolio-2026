{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/hishi/Documents/\\u30DD\\u30FC\\u30C8\\u30D5\\u30A9\\u30EA\\u30AA2026/portfolio/my-portfolio-2026/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/Users/hishi/Documents/\\u30DD\\u30FC\\u30C8\\u30D5\\u30A9\\u30EA\\u30AA2026/portfolio/my-portfolio-2026/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"willChange\"];\nimport { warnOnce, secondsToMilliseconds, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';\nimport { KeyframeResolver } from '../animation/keyframes/KeyframesResolver.mjs';\nimport { NativeAnimation } from '../animation/NativeAnimation.mjs';\nimport { acceleratedValues } from '../animation/waapi/utils/accelerated-values.mjs';\nimport { microtask } from '../frameloop/microtask.mjs';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { motionValue } from '../value/index.mjs';\nimport { complex } from '../value/types/complex/index.mjs';\nimport { getAnimatableNone } from '../value/types/utils/animatable-none.mjs';\nimport { findValueType } from '../value/types/utils/find.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { transformProps } from './utils/keys-transform.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { initPrefersReducedMotion } from './utils/reduced-motion/index.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from './utils/reduced-motion/state.mjs';\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\nconst propEventHandlers = [\"AnimationStart\", \"AnimationComplete\", \"Update\", \"BeforeLayoutMeasure\", \"LayoutMeasure\", \"LayoutAnimationStart\", \"LayoutAnimationComplete\"];\n/**\n * Static feature definitions - can be injected by framework layer\n */\nlet featureDefinitions = {};\n/**\n * Set feature definitions for all VisualElements.\n * This should be called by the framework layer (e.g., framer-motion) during initialization.\n */\nfunction setFeatureDefinitions(definitions) {\n  featureDefinitions = definitions;\n}\n/**\n * Get the current feature definitions\n */\nfunction getFeatureDefinitions() {\n  return featureDefinitions;\n}\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n    return {};\n  }\n  constructor(_ref) {\n    let {\n      parent,\n      props,\n      presenceContext,\n      reducedMotionConfig,\n      skipAnimations,\n      blockInitialAnimation,\n      visualState\n    } = _ref;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    this.current = null;\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    this.children = new Set();\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    this.shouldReduceMotion = null;\n    /**\n     * Decides whether animations should be skipped for this VisualElement.\n     * Useful for E2E tests and visual regression testing.\n     */\n    this.shouldSkipAnimations = false;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    this.values = new Map();\n    this.KeyframeResolver = KeyframeResolver;\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    this.features = {};\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    this.valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    this.prevMotionValues = {};\n    /**\n     * Track whether this element has been mounted before, to detect\n     * remounts after Suspense unmount/remount cycles.\n     */\n    this.hasBeenMounted = false;\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    this.events = {};\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current) return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.renderScheduledAt = 0.0;\n    this.scheduleRender = () => {\n      const now = time.now();\n      if (this.renderScheduledAt < now) {\n        this.renderScheduledAt = now;\n        frame.render(this.render, false, true);\n      }\n    };\n    const {\n      latestValues,\n      renderState\n    } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = _objectSpread({}, latestValues);\n    this.initialValues = props.initial ? _objectSpread({}, latestValues) : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.presenceContext = presenceContext;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.skipAnimationsConfig = skipAnimations;\n    this.options = options;\n    this.blockInitialAnimation = Boolean(blockInitialAnimation);\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't necessarily a breaking change,\n     * more a reflection of the test.\n     */\n    const _this$scrapeMotionVal = this.scrapeMotionValuesFromProps(props, {}, this),\n      {\n        willChange\n      } = _this$scrapeMotionVal,\n      initialMotionValues = _objectWithoutProperties(_this$scrapeMotionVal, _excluded);\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key]);\n      }\n    }\n  }\n  mount(instance) {\n    var _this$skipAnimationsC, _this$parent;\n    /**\n     * If this element has been mounted before (e.g. after a Suspense\n     * unmount/remount), reset motion values to their initial state\n     * so animations replay correctly from initial → animate.\n     */\n    if (this.hasBeenMounted) {\n      for (const key in this.initialValues) {\n        var _this$values$get;\n        (_this$values$get = this.values.get(key)) === null || _this$values$get === void 0 || _this$values$get.jump(this.initialValues[key]);\n        this.latestValues[key] = this.initialValues[key];\n      }\n    }\n    this.current = instance;\n    visualElementStore.set(instance, this);\n    if (this.projection && !this.projection.instance) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = this.parent.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    /**\n     * Determine reduced motion preference. Only initialize the matchMedia\n     * listener if we actually need the dynamic value (i.e., when config\n     * is neither \"never\" nor \"always\").\n     */\n    if (this.reducedMotionConfig === \"never\") {\n      this.shouldReduceMotion = false;\n    } else if (this.reducedMotionConfig === \"always\") {\n      this.shouldReduceMotion = true;\n    } else {\n      if (!hasReducedMotionListener.current) {\n        initPrefersReducedMotion();\n      }\n      this.shouldReduceMotion = prefersReducedMotion.current;\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\", \"reduced-motion-disabled\");\n    }\n    /**\n     * Set whether animations should be skipped based on the config.\n     */\n    this.shouldSkipAnimations = (_this$skipAnimationsC = this.skipAnimationsConfig) !== null && _this$skipAnimationsC !== void 0 ? _this$skipAnimationsC : false;\n    (_this$parent = this.parent) === null || _this$parent === void 0 || _this$parent.addChild(this);\n    this.update(this.props, this.presenceContext);\n    this.hasBeenMounted = true;\n  }\n  unmount() {\n    var _this$parent2;\n    this.projection && this.projection.unmount();\n    cancelFrame(this.notifyUpdate);\n    cancelFrame(this.render);\n    this.valueSubscriptions.forEach(remove => remove());\n    this.valueSubscriptions.clear();\n    this.removeFromVariantTree && this.removeFromVariantTree();\n    (_this$parent2 = this.parent) === null || _this$parent2 === void 0 || _this$parent2.removeChild(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    for (const key in this.features) {\n      const feature = this.features[key];\n      if (feature) {\n        feature.unmount();\n        feature.isMounted = false;\n      }\n    }\n    this.current = null;\n  }\n  addChild(child) {\n    var _this$enteringChildre;\n    this.children.add(child);\n    (_this$enteringChildre = this.enteringChildren) !== null && _this$enteringChildre !== void 0 ? _this$enteringChildre : this.enteringChildren = new Set();\n    this.enteringChildren.add(child);\n  }\n  removeChild(child) {\n    this.children.delete(child);\n    this.enteringChildren && this.enteringChildren.delete(child);\n  }\n  bindToMotionValue(key, value) {\n    if (this.valueSubscriptions.has(key)) {\n      this.valueSubscriptions.get(key)();\n    }\n    if (value.accelerate && acceleratedValues.has(key) && this.current instanceof HTMLElement) {\n      const {\n        factory,\n        keyframes,\n        times,\n        ease,\n        duration\n      } = value.accelerate;\n      const animation = new NativeAnimation({\n        element: this.current,\n        name: key,\n        keyframes,\n        times,\n        ease,\n        duration: secondsToMilliseconds(duration)\n      });\n      const cleanup = factory(animation);\n      this.valueSubscriptions.set(key, () => {\n        cleanup();\n        animation.cancel();\n      });\n      return;\n    }\n    const valueIsTransform = transformProps.has(key);\n    if (valueIsTransform && this.onBindTransform) {\n      this.onBindTransform();\n    }\n    const removeOnChange = value.on(\"change\", latestValue => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && frame.preRender(this.notifyUpdate);\n      if (valueIsTransform && this.projection) {\n        this.projection.isTransformDirty = true;\n      }\n      this.scheduleRender();\n    });\n    let removeSyncCheck;\n    if (typeof window !== \"undefined\" && window.MotionCheckAppearSync) {\n      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n    }\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      if (removeSyncCheck) removeSyncCheck();\n      if (value.owner) value.stop();\n    });\n  }\n  sortNodePosition(other) {\n    /**\n     * If these nodes aren't even of the same type we can't compare their depth.\n     */\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n      return 0;\n    }\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  updateFeatures() {\n    let key = \"animation\";\n    for (key in featureDefinitions) {\n      const featureDefinition = featureDefinitions[key];\n      if (!featureDefinition) continue;\n      const {\n        isEnabled,\n        Feature: FeatureConstructor\n      } = featureDefinition;\n      /**\n       * If this feature is enabled but not active, make a new instance.\n       */\n      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {\n        this.features[key] = new FeatureConstructor(this);\n      }\n      /**\n       * If we have a feature, mount or update it.\n       */\n      if (this.features[key]) {\n        const feature = this.features[key];\n        if (feature.isMounted) {\n          feature.update();\n        } else {\n          feature.mount();\n          feature.isMounted = true;\n        }\n      }\n    }\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n  update(props, presenceContext) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.prevProps = this.props;\n    this.props = props;\n    this.prevPresenceContext = this.presenceContext;\n    this.presenceContext = presenceContext;\n    /**\n     * Update prop event handlers ie onAnimationStart, onAnimationComplete\n     */\n    for (let i = 0; i < propEventHandlers.length; i++) {\n      const key = propEventHandlers[i];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listenerName = \"on\" + key;\n      const listener = props[listenerName];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this), this.prevMotionValues);\n    if (this.handleChildMotionValue) {\n      this.handleChildMotionValue();\n    }\n  }\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n  getVariant(name) {\n    return this.props.variants ? this.props.variants[name] : undefined;\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n  addVariantChild(child) {\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n  addValue(key, value) {\n    // Remove existing value if it exists\n    const existingValue = this.values.get(key);\n    if (value !== existingValue) {\n      if (existingValue) this.removeValue(key);\n      this.bindToMotionValue(key, value);\n      this.values.set(key, value);\n      this.latestValues[key] = value.get();\n    }\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n  removeValue(key) {\n    this.values.delete(key);\n    const unsubscribe = this.valueSubscriptions.get(key);\n    if (unsubscribe) {\n      unsubscribe();\n      this.valueSubscriptions.delete(key);\n    }\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === undefined && defaultValue !== undefined) {\n      value = motionValue(defaultValue === null ? undefined : defaultValue, {\n        owner: this\n      });\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n  readValue(key, target) {\n    var _this$getBaseTargetFr;\n    let value = this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : (_this$getBaseTargetFr = this.getBaseTargetFromProps(this.props, key)) !== null && _this$getBaseTargetFr !== void 0 ? _this$getBaseTargetFr : this.readValueFromInstance(this.current, key, this.options);\n    if (value !== undefined && value !== null) {\n      if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n        // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(target)) {\n        value = getAnimatableNone(key, target);\n      }\n      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n    }\n    return isMotionValue(value) ? value.get() : value;\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n  getBaseTarget(key) {\n    const {\n      initial\n    } = this.props;\n    let valueFromInitial;\n    if (typeof initial === \"string\" || typeof initial === \"object\") {\n      var _this$presenceContext;\n      const variant = resolveVariantFromProps(this.props, initial, (_this$presenceContext = this.presenceContext) === null || _this$presenceContext === void 0 ? void 0 : _this$presenceContext.custom);\n      if (variant) {\n        valueFromInitial = variant[key];\n      }\n    }\n    /**\n     * If this value still exists in the current initial variant, read that.\n     */\n    if (initial && valueFromInitial !== undefined) {\n      return valueFromInitial;\n    }\n    /**\n     * Alternatively, if this VisualElement config has defined a getBaseTarget\n     * so we can read the value from an alternative source, try that.\n     */\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== undefined && !isMotionValue(target)) return target;\n    /**\n     * If the value was initially defined on initial, but it doesn't any more,\n     * return undefined. Otherwise return the value as initially read from the DOM.\n     */\n    return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName) {\n    if (this.events[eventName]) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      this.events[eventName].notify(...args);\n    }\n  }\n  scheduleRenderMicrotask() {\n    microtask.render(this.render);\n  }\n}\nexport { VisualElement, getFeatureDefinitions, setFeatureDefinitions };","map":{"version":3,"names":["propEventHandlers","featureDefinitions","setFeatureDefinitions","definitions","getFeatureDefinitions","VisualElement","scrapeMotionValuesFromProps","_props","_prevProps","_visualElement","constructor","_ref","parent","props","presenceContext","reducedMotionConfig","skipAnimations","blockInitialAnimation","visualState","options","arguments","length","undefined","current","children","Set","isVariantNode","isControllingVariants","shouldReduceMotion","shouldSkipAnimations","values","Map","KeyframeResolver","features","valueSubscriptions","prevMotionValues","hasBeenMounted","events","propEventSubscriptions","notifyUpdate","notify","latestValues","render","triggerBuild","renderInstance","renderState","style","projection","renderScheduledAt","scheduleRender","now","time","frame","baseTarget","_objectSpread","initialValues","initial","depth","skipAnimationsConfig","Boolean","variantChildren","manuallyAnimateOnMount","_this$scrapeMotionVal","willChange","initialMotionValues","_objectWithoutProperties","_excluded","key","value","isMotionValue","set","mount","instance","_this$skipAnimationsC","_this$parent","_this$values$get","get","jump","visualElementStore","removeFromVariantTree","addVariantChild","forEach","bindToMotionValue","hasReducedMotionListener","initPrefersReducedMotion","prefersReducedMotion","process","env","NODE_ENV","warnOnce","addChild","update","unmount","_this$parent2","cancelFrame","remove","clear","removeChild","feature","isMounted","child","_this$enteringChildre","add","enteringChildren","delete","has","accelerate","acceleratedValues","HTMLElement","factory","keyframes","times","ease","duration","animation","NativeAnimation","element","name","secondsToMilliseconds","cleanup","cancel","valueIsTransform","transformProps","onBindTransform","removeOnChange","on","latestValue","onUpdate","preRender","isTransformDirty","removeSyncCheck","window","MotionCheckAppearSync","owner","stop","sortNodePosition","other","sortInstanceNodePosition","type","updateFeatures","featureDefinition","isEnabled","Feature","FeatureConstructor","build","measureViewportBox","measureInstanceViewportBox","createBox","getStaticValue","setStaticValue","transformTemplate","prevProps","prevPresenceContext","i","listenerName","listener","updateMotionValuesFromProps","handleChildMotionValue","getProps","getVariant","variants","getDefaultTransition","transition","getTransformPagePoint","transformPagePoint","getClosestVariantNode","closestVariantNode","addValue","existingValue","removeValue","unsubscribe","removeValueFromRenderState","hasValue","getValue","defaultValue","motionValue","readValue","target","_this$getBaseTargetFr","getBaseTargetFromProps","readValueFromInstance","isNumericalString","isZeroValueString","parseFloat","findValueType","complex","test","getAnimatableNone","setBaseTarget","getBaseTarget","valueFromInitial","_this$presenceContext","variant","resolveVariantFromProps","custom","eventName","callback","SubscriptionManager","_len","args","Array","_key","scheduleRenderMicrotask","microtask"],"sources":["C:\\Users\\hishi\\Documents\\ポートフォリオ2026\\portfolio\\my-portfolio-2026\\node_modules\\motion-dom\\src\\render\\VisualElement.ts"],"sourcesContent":["import {\n    Box,\n    isNumericalString,\n    isZeroValueString,\n    secondsToMilliseconds,\n    SubscriptionManager,\n    warnOnce,\n} from \"motion-utils\"\nimport { KeyframeResolver } from \"../animation/keyframes/KeyframesResolver\"\nimport { NativeAnimation } from \"../animation/NativeAnimation\"\nimport type { AnyResolvedKeyframe } from \"../animation/types\"\nimport { acceleratedValues } from \"../animation/waapi/utils/accelerated-values\"\nimport { cancelFrame, frame } from \"../frameloop\"\nimport { microtask } from \"../frameloop/microtask\"\nimport { time } from \"../frameloop/sync-time\"\nimport type { MotionNodeOptions } from \"../node/types\"\nimport { createBox } from \"../projection/geometry/models\"\nimport { motionValue, MotionValue } from \"../value\"\nimport { complex } from \"../value/types/complex\"\nimport { getAnimatableNone } from \"../value/types/utils/animatable-none\"\nimport { findValueType } from \"../value/types/utils/find\"\nimport { isMotionValue } from \"../value/utils/is-motion-value\"\nimport { Feature } from \"./Feature\"\nimport { visualElementStore } from \"./store\"\nimport {\n    FeatureDefinitions,\n    MotionConfigContextProps,\n    PresenceContextProps,\n    ReducedMotionConfig,\n    ResolvedValues,\n    VisualElementEventCallbacks,\n    VisualElementOptions,\n} from \"./types\"\nimport { AnimationState } from \"./utils/animation-state\"\nimport {\n    isControllingVariants as checkIsControllingVariants,\n    isVariantNode as checkIsVariantNode,\n} from \"./utils/is-controlling-variants\"\nimport { transformProps } from \"./utils/keys-transform\"\nimport { updateMotionValuesFromProps } from \"./utils/motion-values\"\nimport {\n    hasReducedMotionListener,\n    initPrefersReducedMotion,\n    prefersReducedMotion,\n} from \"./utils/reduced-motion\"\nimport { resolveVariantFromProps } from \"./utils/resolve-variants\"\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n] as const\n\n/**\n * Static feature definitions - can be injected by framework layer\n */\nlet featureDefinitions: Partial<FeatureDefinitions> = {}\n\n/**\n * Set feature definitions for all VisualElements.\n * This should be called by the framework layer (e.g., framer-motion) during initialization.\n */\nexport function setFeatureDefinitions(\n    definitions: Partial<FeatureDefinitions>\n) {\n    featureDefinitions = definitions\n}\n\n/**\n * Get the current feature definitions\n */\nexport function getFeatureDefinitions(): Partial<FeatureDefinitions> {\n    return featureDefinitions\n}\n\n/**\n * Motion style type - a subset of CSS properties that can contain motion values\n */\nexport type MotionStyle = {\n    [K: string]: AnyResolvedKeyframe | MotionValue | undefined\n}\n\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nexport abstract class VisualElement<\n    Instance = unknown,\n    RenderState = unknown,\n    Options extends {} = {}\n> {\n    /**\n     * VisualElements are arranged in trees mirroring that of the React tree.\n     * Each type of VisualElement has a unique name, to detect when we're crossing\n     * type boundaries within that tree.\n     */\n    abstract type: string\n\n    /**\n     * An `Array.sort` compatible function that will compare two Instances and\n     * compare their respective positions within the tree.\n     */\n    abstract sortInstanceNodePosition(a: Instance, b: Instance): number\n\n    /**\n     * Measure the viewport-relative bounding box of the Instance.\n     */\n    abstract measureInstanceViewportBox(\n        instance: Instance,\n        props: MotionNodeOptions & Partial<MotionConfigContextProps>\n    ): Box\n\n    /**\n     * When a value has been removed from all animation props we need to\n     * pick a target to animate back to. For instance, for HTMLElements\n     * we can look in the style prop.\n     */\n    abstract getBaseTargetFromProps(\n        props: MotionNodeOptions,\n        key: string\n    ): AnyResolvedKeyframe | undefined | MotionValue\n\n    /**\n     * When we first animate to a value we need to animate it *from* a value.\n     * Often this have been specified via the initial prop but it might be\n     * that the value needs to be read from the Instance.\n     */\n    abstract readValueFromInstance(\n        instance: Instance,\n        key: string,\n        options: Options\n    ): AnyResolvedKeyframe | null | undefined\n\n    /**\n     * When a value has been removed from the VisualElement we use this to remove\n     * it from the inherting class' unique render state.\n     */\n    abstract removeValueFromRenderState(\n        key: string,\n        renderState: RenderState\n    ): void\n\n    /**\n     * Run before a React or VisualElement render, builds the latest motion\n     * values into an Instance-specific format. For example, HTMLVisualElement\n     * will use this step to build `style` and `var` values.\n     */\n    abstract build(\n        renderState: RenderState,\n        latestValues: ResolvedValues,\n        props: MotionNodeOptions\n    ): void\n\n    /**\n     * Apply the built values to the Instance. For example, HTMLElements will have\n     * styles applied via `setProperty` and the style attribute, whereas SVGElements\n     * will have values applied to attributes.\n     */\n    abstract renderInstance(\n        instance: Instance,\n        renderState: RenderState,\n        styleProp?: MotionStyle,\n        projection?: any\n    ): void\n\n    /**\n     * This method is called when a transform property is bound to a motion value.\n     * It's currently used to measure SVG elements when a new transform property is bound.\n     */\n    onBindTransform?(): void\n\n    /**\n     * If the component child is provided as a motion value, handle subscriptions\n     * with the renderer-specific VisualElement.\n     */\n    handleChildMotionValue?(): void\n\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(\n        _props: MotionNodeOptions,\n        _prevProps: MotionNodeOptions,\n        _visualElement: VisualElement\n    ): {\n        [key: string]: MotionValue | AnyResolvedKeyframe\n    } {\n        return {}\n    }\n\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    current: Instance | null = null\n\n    /**\n     * A reference to the parent VisualElement (if exists).\n     */\n    parent: VisualElement | undefined\n\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    children = new Set<VisualElement>()\n\n    /**\n     * A set containing the latest children of this VisualElement. This is flushed\n     * at the start of every commit. We use it to calculate the stagger delay\n     * for newly-added children.\n     */\n    enteringChildren?: Set<VisualElement>\n\n    /**\n     * The depth of this VisualElement within the overall VisualElement tree.\n     */\n    depth: number\n\n    /**\n     * The current render state of this VisualElement. Defined by inherting VisualElements.\n     */\n    renderState: RenderState\n\n    /**\n     * An object containing the latest static values for each of this VisualElement's\n     * MotionValues.\n     */\n    latestValues: ResolvedValues\n\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    isVariantNode: boolean = false\n    isControllingVariants: boolean = false\n\n    /**\n     * If this component is part of the variant tree, it should track\n     * any children that are also part of the tree. This is essentially\n     * a shadow tree to simplify logic around how to stagger over children.\n     */\n    variantChildren?: Set<VisualElement>\n\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    shouldReduceMotion: boolean | null = null\n\n    /**\n     * Decides whether animations should be skipped for this VisualElement.\n     * Useful for E2E tests and visual regression testing.\n     */\n    shouldSkipAnimations: boolean = false\n\n    /**\n     * Normally, if a component is controlled by a parent's variants, it can\n     * rely on that ancestor to trigger animations further down the tree.\n     * However, if a component is created after its parent is mounted, the parent\n     * won't trigger that mount animation so the child needs to.\n     *\n     * TODO: This might be better replaced with a method isParentMounted\n     */\n    manuallyAnimateOnMount: boolean\n\n    /**\n     * This can be set by AnimatePresence to force components that mount\n     * at the same time as it to mount as if they have initial={false} set.\n     */\n    blockInitialAnimation: boolean\n\n    /**\n     * A reference to this VisualElement's projection node, used in layout animations.\n     */\n    projection?: any\n\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    values = new Map<string, MotionValue>()\n\n    /**\n     * The AnimationState, this is hydrated by the animation Feature.\n     */\n    animationState?: AnimationState\n\n    KeyframeResolver = KeyframeResolver\n\n    /**\n     * The options used to create this VisualElement. The Options type is defined\n     * by the inheriting VisualElement and is passed straight through to the render functions.\n     */\n    readonly options: Options\n\n    /**\n     * A reference to the latest props provided to the VisualElement's host React component.\n     */\n    props: MotionNodeOptions\n    prevProps?: MotionNodeOptions\n\n    presenceContext: PresenceContextProps | null\n    prevPresenceContext?: PresenceContextProps | null\n\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    private features: {\n        [K in keyof FeatureDefinitions]?: Feature<Instance>\n    } = {}\n\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    private valueSubscriptions = new Map<string, VoidFunction>()\n\n    /**\n     * A reference to the ReducedMotionConfig passed to the VisualElement's host React component.\n     */\n    private reducedMotionConfig: ReducedMotionConfig | undefined\n\n    /**\n     * A reference to the skipAnimations config passed to the VisualElement's host React component.\n     */\n    private skipAnimationsConfig: boolean | undefined\n\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n    private removeFromVariantTree: undefined | VoidFunction\n\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    private prevMotionValues: MotionStyle = {}\n\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n    private baseTarget: ResolvedValues\n\n    /**\n     * Create an object of the values we initially animated from (if initial prop present).\n     */\n    private initialValues: ResolvedValues\n\n    /**\n     * Track whether this element has been mounted before, to detect\n     * remounts after Suspense unmount/remount cycles.\n     */\n    private hasBeenMounted = false\n\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    private events: {\n        [key: string]: SubscriptionManager<any>\n    } = {}\n\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    private propEventSubscriptions: {\n        [key: string]: VoidFunction\n    } = {}\n\n    constructor(\n        {\n            parent,\n            props,\n            presenceContext,\n            reducedMotionConfig,\n            skipAnimations,\n            blockInitialAnimation,\n            visualState,\n        }: VisualElementOptions<Instance, RenderState>,\n        options: Options = {} as any\n    ) {\n        const { latestValues, renderState } = visualState\n        this.latestValues = latestValues\n        this.baseTarget = { ...latestValues }\n        this.initialValues = props.initial ? { ...latestValues } : {}\n        this.renderState = renderState\n        this.parent = parent\n        this.props = props\n        this.presenceContext = presenceContext\n        this.depth = parent ? parent.depth + 1 : 0\n        this.reducedMotionConfig = reducedMotionConfig\n        this.skipAnimationsConfig = skipAnimations\n        this.options = options\n        this.blockInitialAnimation = Boolean(blockInitialAnimation)\n\n        this.isControllingVariants = checkIsControllingVariants(props)\n        this.isVariantNode = checkIsVariantNode(props)\n        if (this.isVariantNode) {\n            this.variantChildren = new Set()\n        }\n\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current)\n\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } =\n            this.scrapeMotionValuesFromProps(props, {}, this)\n\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key]\n\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key])\n            }\n        }\n    }\n\n    mount(instance: Instance) {\n        /**\n         * If this element has been mounted before (e.g. after a Suspense\n         * unmount/remount), reset motion values to their initial state\n         * so animations replay correctly from initial → animate.\n         */\n        if (this.hasBeenMounted) {\n            for (const key in this.initialValues) {\n                this.values.get(key)?.jump(this.initialValues[key])\n                this.latestValues[key] = this.initialValues[key]\n            }\n        }\n\n        this.current = instance\n\n        visualElementStore.set(instance, this)\n\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance)\n        }\n\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this)\n        }\n\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value))\n\n        /**\n         * Determine reduced motion preference. Only initialize the matchMedia\n         * listener if we actually need the dynamic value (i.e., when config\n         * is neither \"never\" nor \"always\").\n         */\n        if (this.reducedMotionConfig === \"never\") {\n            this.shouldReduceMotion = false\n        } else if (this.reducedMotionConfig === \"always\") {\n            this.shouldReduceMotion = true\n        } else {\n            if (!hasReducedMotionListener.current) {\n                initPrefersReducedMotion()\n            }\n            this.shouldReduceMotion = prefersReducedMotion.current\n        }\n\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(\n                this.shouldReduceMotion !== true,\n                \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\",\n                \"reduced-motion-disabled\"\n            )\n        }\n\n        /**\n         * Set whether animations should be skipped based on the config.\n         */\n        this.shouldSkipAnimations = this.skipAnimationsConfig ?? false\n\n        this.parent?.addChild(this)\n\n        this.update(this.props, this.presenceContext)\n\n        this.hasBeenMounted = true\n    }\n\n    unmount() {\n        this.projection && this.projection.unmount()\n        cancelFrame(this.notifyUpdate)\n        cancelFrame(this.render)\n        this.valueSubscriptions.forEach((remove) => remove())\n        this.valueSubscriptions.clear()\n        this.removeFromVariantTree && this.removeFromVariantTree()\n        this.parent?.removeChild(this)\n\n        for (const key in this.events) {\n            this.events[key].clear()\n        }\n\n        for (const key in this.features) {\n            const feature = this.features[key as keyof typeof this.features]\n            if (feature) {\n                feature.unmount()\n                feature.isMounted = false\n            }\n        }\n        this.current = null\n    }\n\n    addChild(child: VisualElement) {\n        this.children.add(child)\n        this.enteringChildren ??= new Set()\n        this.enteringChildren.add(child)\n    }\n\n    removeChild(child: VisualElement) {\n        this.children.delete(child)\n        this.enteringChildren && this.enteringChildren.delete(child)\n    }\n\n    private bindToMotionValue(key: string, value: MotionValue) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)!()\n        }\n\n        if (\n            value.accelerate &&\n            acceleratedValues.has(key) &&\n            this.current instanceof HTMLElement\n        ) {\n            const { factory, keyframes, times, ease, duration } =\n                value.accelerate\n\n            const animation = new NativeAnimation({\n                element: this.current,\n                name: key,\n                keyframes,\n                times,\n                ease,\n                duration: secondsToMilliseconds(duration),\n            })\n\n            const cleanup = factory(animation)\n\n            this.valueSubscriptions.set(key, () => {\n                cleanup()\n                animation.cancel()\n            })\n            return\n        }\n\n        const valueIsTransform = transformProps.has(key)\n\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform()\n        }\n\n        const removeOnChange = value.on(\n            \"change\",\n            (latestValue: AnyResolvedKeyframe) => {\n                this.latestValues[key] = latestValue\n\n                this.props.onUpdate && frame.preRender(this.notifyUpdate)\n\n                if (valueIsTransform && this.projection) {\n                    this.projection.isTransformDirty = true\n                }\n\n                this.scheduleRender()\n            }\n        )\n\n        let removeSyncCheck: VoidFunction | void\n        if (\n            typeof window !== \"undefined\" &&\n            (window as any).MotionCheckAppearSync\n        ) {\n            removeSyncCheck = (window as any).MotionCheckAppearSync(\n                this,\n                key,\n                value\n            )\n        }\n\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange()\n            if (removeSyncCheck) removeSyncCheck()\n            if (value.owner) value.stop()\n        })\n    }\n\n    sortNodePosition(other: VisualElement<Instance>) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (\n            !this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type\n        ) {\n            return 0\n        }\n\n        return this.sortInstanceNodePosition(\n            this.current as Instance,\n            other.current as Instance\n        )\n    }\n\n    updateFeatures() {\n        let key: keyof typeof featureDefinitions = \"animation\"\n\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key]\n\n            if (!featureDefinition) continue\n\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition\n\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (\n                !this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)\n            ) {\n                this.features[key] = new FeatureConstructor(this) as any\n            }\n\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key]!\n                if (feature.isMounted) {\n                    feature.update()\n                } else {\n                    feature.mount()\n                    feature.isMounted = true\n                }\n            }\n        }\n    }\n\n    notifyUpdate = () => this.notify(\"Update\", this.latestValues)\n\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props)\n    }\n\n    render = () => {\n        if (!this.current) return\n        this.triggerBuild()\n        this.renderInstance(\n            this.current,\n            this.renderState,\n            (this.props as any).style,\n            this.projection\n        )\n    }\n\n    private renderScheduledAt = 0.0\n    scheduleRender = () => {\n        const now = time.now()\n        if (this.renderScheduledAt < now) {\n            this.renderScheduledAt = now\n            frame.render(this.render, false, true)\n        }\n    }\n\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox()\n    }\n\n    getStaticValue(key: string) {\n        return this.latestValues[key]\n    }\n\n    setStaticValue(key: string, value: AnyResolvedKeyframe) {\n        this.latestValues[key] = value\n    }\n\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(\n        props: MotionNodeOptions,\n        presenceContext: PresenceContextProps | null\n    ) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender()\n        }\n\n        this.prevProps = this.props\n        this.props = props\n\n        this.prevPresenceContext = this.presenceContext\n        this.presenceContext = presenceContext\n\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i]\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]()\n                delete this.propEventSubscriptions[key]\n            }\n\n            const listenerName = (\"on\" + key) as keyof typeof props\n            const listener = props[listenerName]\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key as any, listener)\n            }\n        }\n\n        this.prevMotionValues = updateMotionValuesFromProps(\n            this,\n            this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this),\n            this.prevMotionValues\n        )\n\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue()\n        }\n    }\n\n    getProps() {\n        return this.props\n    }\n\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name: string) {\n        return this.props.variants ? this.props.variants[name] : undefined\n    }\n\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition\n    }\n\n    getTransformPagePoint() {\n        return (this.props as any).transformPagePoint\n    }\n\n    getClosestVariantNode(): VisualElement | undefined {\n        return this.isVariantNode\n            ? this\n            : this.parent\n            ? this.parent.getClosestVariantNode()\n            : undefined\n    }\n\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child: VisualElement) {\n        const closestVariantNode = this.getClosestVariantNode()\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child)\n            return () => closestVariantNode.variantChildren!.delete(child)\n        }\n    }\n\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key: string, value: MotionValue) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key)\n\n        if (value !== existingValue) {\n            if (existingValue) this.removeValue(key)\n            this.bindToMotionValue(key, value)\n            this.values.set(key, value)\n            this.latestValues[key] = value.get()\n        }\n    }\n\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key: string) {\n        this.values.delete(key)\n        const unsubscribe = this.valueSubscriptions.get(key)\n        if (unsubscribe) {\n            unsubscribe()\n            this.valueSubscriptions.delete(key)\n        }\n        delete this.latestValues[key]\n        this.removeValueFromRenderState(key, this.renderState)\n    }\n\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key: string) {\n        return this.values.has(key)\n    }\n\n    /**\n     * Get a motion value for this key. If called with a default\n     * value, we'll create one if none exists.\n     */\n    getValue(key: string): MotionValue | undefined\n    getValue(key: string, defaultValue: AnyResolvedKeyframe | null): MotionValue\n    getValue(\n        key: string,\n        defaultValue?: AnyResolvedKeyframe | null\n    ): MotionValue | undefined {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key]\n        }\n\n        let value = this.values.get(key)\n\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(\n                defaultValue === null ? undefined : defaultValue,\n                { owner: this }\n            )\n            this.addValue(key, value)\n        }\n\n        return value\n    }\n\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key: string, target?: AnyResolvedKeyframe | null) {\n        let value =\n            this.latestValues[key] !== undefined || !this.current\n                ? this.latestValues[key]\n                : this.getBaseTargetFromProps(this.props, key) ??\n                  this.readValueFromInstance(this.current, key, this.options)\n\n        if (value !== undefined && value !== null) {\n            if (\n                typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))\n            ) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value)\n            } else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target as string)\n            }\n\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value)\n        }\n\n        return isMotionValue(value) ? value.get() : value\n    }\n\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key: string, value: AnyResolvedKeyframe) {\n        this.baseTarget[key] = value\n    }\n\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key: string): ResolvedValues[string] | undefined | null {\n        const { initial } = this.props\n\n        let valueFromInitial: ResolvedValues[string] | undefined | null\n\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(\n                this.props,\n                initial as any,\n                this.presenceContext?.custom\n            )\n            if (variant) {\n                valueFromInitial = variant[\n                    key as keyof typeof variant\n                ] as string\n            }\n        }\n\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial\n        }\n\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key)\n        if (target !== undefined && !isMotionValue(target)) return target\n\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key]\n    }\n\n    on<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        callback: VisualElementEventCallbacks[EventName]\n    ) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager()\n        }\n\n        return this.events[eventName].add(callback)\n    }\n\n    notify<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        ...args: any\n    ) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args)\n        }\n    }\n\n    scheduleRenderMicrotask() {\n        microtask.render(this.render)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}